#!/usr/bin/env bash

## Copyright (c) 2024 by Adam Korab <adam.korab@sixpackets.com>
## All rights reserved.
##
## This code is maintained by
## Adam Korab 
## and is contributed to by 
## Adam Korab, Dan Gast, Tim Burke, Justin Handa, Swen Wulf
##
## Spiritual inspiration comes from and gratitude for supporting work goes to:
##
## IRR Explorer	(DashCare BV [https://www.dashcare.nl] + Stichting NLNOG [https://www.nlnog.net])
##  [https://irrexplorer.nlnog.net]
##  [https://github.com/nlnog/irrexplorer]
##
## Daniel Austin MBCS (https://www.dan.me.uk/filtergen)
##
## Special thanks to Ken Kresha and the rest of the AS2914 crew for igniting my IRR knowledge and
## curiosity, way back a million years ago in the Y2K!

START_TIME=$(date +%s.%N)

# Usage function to display help message
usage() {
    echo " "
    echo "irr-toolbox:recurse-prefixes - get prefixes by as-set from IRR"
    echo " "
    echo "Recurse a given as-set object through member aut-nums and member as-sets which themselves contain."
    echo "aut-nums, until the end-of-recursion aut-num is reached. Query aut-num objects for originated prefixes."
    echo " "
	echo "Uses ANSI colors by default.  Suggested terminal width is >=120 columns"
	echo " "
    echo "Usage: $0 <as_set_name|aut-num> [-m|--mnt <mnt-by> -s|--source <irr_source> <as_set_name> [-i|--info -w|--warning --debug -h|--help]"
    echo " "
    printf "%-30s %-80s \n" "<as_set_name|aut-num>" "The IRR object you wish to enumerate"
    printf "%-30s %-80s \n" "-c|--chain" "Output IRR data relative to each prefix, e.g., as-set recusion until aut-num for origin"
    printf "%-30s %-80s \n" "" "Useful when combined with -i|--info"
    printf "%-30s %-80s \n" "-m|--mnt <mnt-by>" "The name of your maintainer holding *your* as-set, route, and other IRR objects"
    printf "%-30s %-80s \n" "" "Assumed to be the maintainer of the as-set but can be overriden with this flag"
    printf "%-30s %-80s \n" "" "if you have a reason to do so"
    printf "%-30s %-80s \n" "-s|--source <irr_source>" "Name of IRR to query such as NTTCOM, RADB, ALTDB, LEVEL3"
    printf "%-30s %-80s \n" "" "See https://irr.net/registry for full list of SOURCE options"
    printf "%-30s %-80s \n" "" "Defaults to NTTCOM if not specified"
    printf "%-30s %-80s \n" "-i|--info"	"Output verbose extra information about the enumerated route objects from the as-set"
    printf "%-30s %-80s \n" "" "Implicitly sets -w|--warning"
    printf "%-30s %-80s \n" "-w|--warning"	"See warnings about possible IRR data issues (without extra output of -i|--info)"
    printf "%-30s %-80s \n" "--debug" "Enable script execution debugging - there is a prodigious amount"
    printf "%-30s %-80s \n" "" "of output; use judiciously and don't say we didn't warn you."
    printf "%-30s %-80s \n" "" "Implicitly sets -i|--info and -w|--warning"
    printf "%-30s %-80s \n" "-h|--help" "# Print this help message and exit"
    printf "\n"
    exit 1
}

# If no arguments are provided, print usage and exit
if [ $# -eq 0 ]; then
    usage
fi

## Colors and Backgrounds

red="\e[0;91m"
blue="\e[0;94m"
yellow="\e[33m"
expand_bg="\e[K"
blue_bg="\e[0;104m${expand_bg}"
red_bg="\e[0;101m${expand_bg}"
green_bg="\e[0;102m${expand_bg}"
inverted="\e[7m${expand_bg}"
red_bg_bold_white="\e[1;37m\e[41m${expand_bg}"
green="\e[0;92m"
white="\e[0;97m"
bold="\e[1m"
uline="\e[4m"
blink="\e[5m"
reset="\e[0m"

### BEGIN SECTION: DATABASES

## BOGONDB START
# Suck in the bogons db 
BOGONDB=()
while IFS= read -r bogondb_line; do
    BOGONDB+=("$bogondb_line")
done < "bogon-bn-nonagg.txt"
## BOGONDB END

## IANA_DB START

# Initialize the IANA_DB array to store the processed records
IANA_DB=()
IANA_SRC_FILE="ipv4-address-space.txt"

    while IFS= read -r line; do
        iana_prefix=$(echo "$line" | cut -c4-9 | sed 's/^0\{1,2\}//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//') 
        iana_designation=$(echo "$line" | cut -c11-45 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//') 
        iana_whois=$(echo "$line" | cut -c53-71 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')  
        iana_status=$(echo "$line" | cut -c103-113 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')  
        row="$(printf "%-10s|%-45s|%-25s|%-15s\n" "$iana_prefix" "$iana_designation" "$iana_whois" "$iana_status")"
        # Append the formatted string to the array
        IANA_DB+=("$row")
	done < "$IANA_SRC_FILE"

# To view the array content
#for row in "${IANA_DB[@]}"; do
#	echo "row: $row"
#done

## IANA_DB END

#### END SECTION: DATABASES

#### BEGIN SECTION: BASH FUNCTIONS

printf_debug() {
	printf "${white}$1${reset}\n"
}

printf_info() {
	printf "${yellow}$1${reset}\n"
}

printf_info_bold () {
	printf "${yellow}${bold}$1${reset}\n"
}

printf_warn() {
	printf "${red_bg_bold_white}$1${reset}\n"
}

printf_inverted() {
	printf "${inverted}$1${reset}\n"
}

is_visited_pfx() {
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: is_visited_pfx start for $PREFIX"
	#fi

	if [ ${VISITED_PFX["$PREFIX"]} = "false" ]; then
		# ADD DEBUG
		#if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: is_visited_pfx() $PREFIX - match if VISITED_PFX[PREFIX]=false - eval to: "${VISITED_PFX["$PREFIX"]}""
			printf_debug "+DEBUG: is_visited_pfx() $PREFIX - counter++ now"
			printf_debug "+DEBUG: is_visited_pfx() $PREFIX visited was false - now we set it to true based on *this* iteration"
		#fi
		((irr_prefix_count++))  # Increment the prefix counter
		VISITED_PFX["$PREFIX"]=true
	elif [ ${VISITED_PFX["$PREFIX"]} = "true" ]; then
		# ADD DEBUG
		#if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: is_visited_pfx() $PREFIX - match elif VISITED_PFX[PREFIX]=true - eval to "${VISITED_PFX["$PREFIX"]}""
			printf_debug "+DEBUG: is_visited_pfx() $PREFIX - match elif - do not increment counter"
		#fi
		if [ "$INFO" = "1" ]; then
			printf_info "+INFO: is_visited_pfx(): Already encountered $PREFIX - not incrementing unique prefix count"	
		fi
	fi

	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_debug "+DEBUG: is_visited_pfx() $PREFIX - irr_prefix_count: "$irr_prefix_count""
		printf_inverted "+DEBUG: is_visited_pfx end for $PREFIX"
		printf "\n"
	#fi
}

conditional_supression() {
	if [[ $PREFIX =~ ^44. ]]; then
		if [ "$INFO" = "1" ]; then
			printf_info "+INFO: 44net prefix detected, suppressing proxy reg warning because you can't create RIR route objects"
			printf_info "+INFO: for 44net prefixes and they're often proxy registered for inclusion in filter prefix-lists, which"
			printf_info "+INFO: is usually done by another mntner in a non-RIR registry"
		fi
	SUPPRESSED="true"
	elif [[ "${ROUTE_MNT[$o]}" = "MAINT-AS20473" && "${ROUTE_SRC[$o]}" = "RADB" ]]; then
		if [ "$INFO" = "1" ]; then
			printf_info "+INFO: Suppressing mnt-by mismatch warning because it's Vultr in RADB, and that's just how they do things :("
		fi
	SUPPRESSED="true"
	else
	SUPPRESSED="true"
	fi
}

is_mask_le_24_warning() {
	if (( CIDRMASK > 24 )) && [ "$WARNING" = "1" ]; then
		printf_warning "+WARNING: Mask length >24.  This will not be accepted in global filter lists!"
	fi
}

check_bogons() {
	# ADD DEBUG
	#if [ "$DEBUG" = "1" =; then
		printf_inverted "+DEBUG: check_bogons() start for $PREFIX"
	#fi
	# First, unset IS_BOGON from previous run, if any
	unset IS_BOGON

    ## There's some convoluted bitwise and hex value handling in this function.
    ## Blame MS Visual Studio Code, it complained mightily about the first 4 ways I wrote this
    ## and broke syntax highlighting through the rest of the script. Sorry. :(

    local base_ip=${PREFIX%%/*}  # Extract base IP from $PREFIX
    local bogon_match=0  # Flag to track if a match is found

    for bogon in "${BOGONDB[@]}"; do
        local bogon_base=${bogon%%/*}
        local bogon_len=${bogon#*/}

        # Convert the prefix's base IP to a 32-bit decimal
        local a b c d
        IFS=. read -r a b c d <<<"${base_ip}"
        local base_dec=$(( (a * 256**3) + (b * 256**2) + (c * 256) + d ))

        # Convert the bogon base IP to a 32-bit decimal
        local e f g h
        IFS=. read -r e f g h <<<"${bogon_base}"
        local bogon_dec=$(( (e * 256**3) + (f * 256**2) + (g * 256) + h ))

        # Calculate the shift value and mask for the range
        local shift=$((32 - bogon_len))

        # Manually construct the mask by shifting the bits in multiple steps
        local mask_part1=$((0xFFFFFFFF))  # Full 32-bit mask
        local mask=$((mask_part1 << shift))  # Apply the shift
		
		## Leaving the next two commented lines in there because it unfucks the syntax highlighter
        # Alternatively, without hexadecimal:
        # local mask=$(( ((1 << 32) - 1) << shift ))

        # Check if the prefix falls within a bogon range
        if (( (base_dec & mask) == (bogon_dec & mask) )); then
			IS_BOGON=1		# Is bogon
            break 
        elif (( (base_dec & mask) != (bogon_dec & mask) )); then
            IS_BOGON=0		# Is NOT bogon
        else
            printf_inverted "ERROR: check_bogons() else - corner case encountered for $PREFIX"
			exit 1
        fi
    done
	if [ "$INFO" = "1" ]; then
		if [ "$IS_BOGON" = "0" ]; then
			printf_info "+INFO: Not part of known bogon space"
		elif [ "$IS_BOGON" = "1"  ]; then
			printf_warn "+WARNING: $PREFIX is within bogon space and route: $PREFIX should not be found in IRR"
		else
			printf_debug "+ERROR: Bogon status evaluation has failed!"
		fi
	fi
	# ADD DEBUG
	#if [ "DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: check_bogons() end for $PREFIX\n"
	#fi
}

rir_query() {
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: rir_query() start for $PREFIX"
	#fi

	# Get first octet from prefix
	IANA_SLASH8="$(echo "$PREFIX" | cut -d '.' -f1)/8"
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
	printf_debug "+DEBUG:  IANA_SLASH8: [$IANA_SLASH8]"
	#fi

    for line in "${IANA_DB[@]}"; do
        # Split the entry into individual components
        IFS='|' read -r iana_prefix iana_designation iana_whois iana_status <<< "$line"
		# Check if the current entry matches the IANA_SLASH8.  If it does:
        if [[ $iana_prefix == "$IANA_SLASH8" ]]; then
			# ADD DEBUG
			#if [ "$DEBUG" = "1" ]; then
				printf_debug "+DEBUG: iana_prefix: [$iana_prefix] == IANA_SLASH8: [$IANA_SLASH8]"
				printf_debug "+DEBUG: iana_status: [$iana_status]"
				printf_debug "+DEBUG: iana_whois: [$iana_whois]"
			#fi
            # If the status is RESERVED, set IS_BOGON=1 and exit immediately
            if [[ $iana_status == "RESERVED" ]]; then
                printf_inverted "rir_query() IANA status=RESERVED - is bogon"
				IS_BOGON=1
                break
			fi

            # If not a bogon, eval status for ALLOCATED or LEGACY
            if [[ $iana_status == "ALLOCATED" || $iana_status == "LEGACY" ]]; then
			# If status matches, look at iana_whois to set the appropriate RIR
                if [[ $iana_whois == *"apnic"* ]]; then
                    RIR="APNIC"
					printf_inverted "rir_query() match RIR=$RIR"
                elif [[ $iana_whois == *"ripe"* ]]; then
                    RIR="RIPE"
					printf_inverted "rir_query() match RIR=$RIR"
                elif [[ $iana_whois == *"arin"* ]]; then
                    RIR="ARIN"
					printf_inverted "rir_query() match RIR=$RIR"
                elif [[ $iana_whois == *"afrinic"* ]]; then
                    RIR="AFRINIC"
					printf_inverted "rir_query() match RIR=$RIR"
                elif [[ $iana_whois == *"lacnic"* ]]; then
                    RIR="LACNIC"
					printf_inverted "rir_query() match RIR=$RIR"
                else
                    printf_inverted "+ERROR: RIR match failure for $PREFIX"
                fi
            fi
            # Exit loop after evaluating the matching line
            break
        fi
    done

	# query ARIN 
	#if [ "$RIR" = "ARIN" ]; then
	#	# OrgId
	#	ARIN_ORG_ID=$(whois -h whois.arin.net "r = $PREFIX" | awk '/^OrgId:/ {print $2}')
	#	if [ -z "$ARIN_ORG_ID" ]; then
	#		ARIN_ORG_ID="arin_no_match_found"
	#	fi
	#	# Ref URL for OrgId
	#	ARIN_ORG_REF=$(whois -h whois.arin.net "r = $PREFIX" | awk '/^OrgId:/ {found=1} found && /^Ref:/ {print $2; exit}')
	#	if [ -z "$ARIN_ORG_REF" ]; then
	#		ARIN_ORG_REF="arin_no_match_found"
	#	fi
	#fi
	printf_info "+INFO: rir_query() RIR: $RIR"
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: rir_query() end for $PREFIX"
	#fi
}

do_output() {
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: do_output() start"
	#fi
	
	if [ "$INFO" = "1" ]; then			# Print header for INFO
	    	printf_info "INFO: Recursing as-set: ["$AS_SET"] mnt-by: ["${ASS_MNT_ARRAY[0]}"] source: ["${ASS_SRC_ARRAY[0]}"]"
	fi
	if [ "$INFO_CHAIN" = "1" ]; then	# Print header for INFO_CHAIN
		printf "\n"
		printf "$PREFIX (enumerated from "${AS_SET_STACK[@]}"->$MEMBER)"
		printf "\n"
	elif [ "$WARNING" = "1" ]; then		# Print header for WARNING
		printf "\n$PREFIX\n"
	else								# Normal output when INFO|INFO_CHAIN|WARNING are false
		if [ "$PREFIX" == "$OUTPUT_PREFIX" ]; then
			break
		else
			OUTPUT_PREFIX=$(echo "$KVP" | awk '{print $1}')	
			printf "\n$PREFIX\n"
		fi
	fi

	if [ "$INFO" = "1" ]; then
		printf_info "+INFO: Prefix length: $CIDRMASK"
	fi
	printf_debug "+DEBUG: do_output() calling route_qty_check()"
	route_qty_check
	printf_debug "+DEBUG: do_output() calling route_mntby_autnum_mntby_check()"
	route_mntby_autnum_mntby_check
	printf_debug "+DEBUG: do_output() calling is_visited_pfx()"
	is_visited_pfx	
	printf_debug "+DEBUG: do_output() calling check_bogons()"
	check_bogons
	printf_debug "+DEBUG: do_output() calling rir_query()"
	rir_query

	if [ "$PFX_MATCH" = "c0" ]; then 
        # CHANGE TO DEBUG
        if [ "$INFO" = "1" ]; then
            printf_debug "+DEBUG: c0 match - ROUTE_ORIGIN[o] == MEMBER and ROUTE_MNT[o] == AUT_MNT"
        fi
		conditional_supression
        if [ "$INFO" = "1" ]; then
        	printf_info "+INFO: This route object has same mnt-by as origin AS - ${uline}best candidate IRR data!"
		fi

	elif [ "$PFX_MATCH" = "c1" ]; then
        # CHANGE TO DEBUG
        if [ "$INFO" = "1" ]; then
            printf_debug "+DEBUG: c1 match" 
        fi
		conditional_supression
		if [ "$SUPPRESSED" != "true" ]; then
			if [ "$INFO" = "1" ]; then
        		printf_info_bold "+INFO: route: "$PREFIX" mnt-by: "${ROUTE_MNT[$o]}" ["${ROUTE_SRC[$o]}"] != "$MEMBER" mnt-by: "$MY_MNT"" 
        		printf_info_bold "+INFO: route: is either proxy registered or bogus data."
			fi
		fi

	elif [ "$PFX_MATCH" = "c2" ]; then
		# CHANGE TO DEBUG
        if [ "$INFO" = "1" ]; then
			printf_debug "+DEBUG: c2 match - ROUTE_ORIGIN[o] != MEMBER"
		fi
		conditional_supression

	elif [ "$PFX_MATCH" = "c3" ]; then
		# CHANGE TO DEBUG
        if [ "$INFO" = "1" ]; then
            printf_debug "+DEBUG: c3 match - route with identical attributes seen in >1 registry"
		fi
		conditional_supression
		if [ "$WARNING" = "1" ]; then
        	printf_warn "+WARNING: This route object exists identically in multi reg. - ${uline}best candidate IRR data, consider deleting redundant data"
		fi

	elif [ "$PFX_MATCH" = "c4" ]; then
		# CHANGE TO DEBUG
        if [ "$INFO" = "1" ]; then
            printf_debug "+DEBUG: c4 match - [at least 1] route origin inconsistent with RIR origin"
		fi
		conditional_supression
	fi
	
	if [ "$INFO" = "1" ]; then
    	printf_info "+INFO: Cumulative unique prefix count: $irr_prefix_count"
	fi

	if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: "$PFX_MATCH" setting VISITED_PFX_SRC[KVP] =1 for ["$KVP"]"
	fi
	VISITED_PFX_SRC[$KVP]=1
	if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: $PREFIX $PFX_MATCH for o loop iteration end"
        printf_debug "DEBUG: $PREFIX unset PFX_MATCH (was: "$PFX_MATCH")"
	fi                                                      
	unset PFX_MATCH
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_inverted "DEBUG: do_output() end"
		## REMOVE THIS NEWLINE
		printf "\n"
	#fi
}

route_qty_check () {
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: route_qty_check() start for $PREFIX"
	#fi
	if [ "$INFO" = "1" ]; then
			printf_info "+INFO: Found "${#ROUTE_QTY[@]}" [route: $PREFIX] object(s) in IRR. 1 is the optimal quantity"
	fi
	if [[ ${#ROUTE_QTY[@]} -eq 1 ]]; then
		if [ "$INFO" = "1" ]; then
			for i in "${!ROUTE_QTY[@]}"; do
					printf_info "+INFO:  ["$i"] route: $PREFIX source: "${ROUTE_SRC["$i"]}" mnt-by: "${ROUTE_MNT["$i"]}" origin: "${ROUTE_ORIGIN["$i"]}""
			done	
		fi
	elif [[ ${#ROUTE_QTY[@]} -gt 1 ]]; then
		if [ "$INFO" = "1" ]; then
			printf_info "+++INFO: >1 objects exist in IRR for route: $PREFIX"
		fi
		for i in "${!ROUTE_QTY[@]}"; do
			if [ "${ROUTE_MNT["$i"]}" == "MAINT-AS20473" ] && [ "${ROUTE_SRC["$i"]}" = "RADB" ]; then
				break
				if [ "$INFO" = "1" ]; then
					printf_info "+++INFO: Suppressed >1 route warning because it's Vultr in RADB, and that's just how they do things :("
				fi
			elif [[ "$PREFIX" =~ ^44\. ]]; then
				break
				if [ "$INFO" = "1" ]; then
					printf_info "+++INFO: Suppressed >1 route warning because prefix is 44net. As such, almost always needs a proxy reg"
				fi
			else
				if [ "$INFO" = "1" ]; then
					printf_info "+++INFO:   ["$i"] route: $PREFIX source: "${ROUTE_SRC["$i"]}" mnt-by: "${ROUTE_MNT["$i"]}" origin: "${ROUTE_ORIGIN["$i"]}""
				fi
			fi
		done
	fi
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: route_qty_check() end for $PREFIX\n"
	#fi
}

route_origin_irr_check() {
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: route_origin_irr_check() start for $PREFIX"
		printf_debug "+DEBUG: route_origin_irr_check() count elements in {#ROUTE_ORIGIN[@]}: ${#ROUTE_ORIGIN[@]}"
	#fi
	# if more than one origin: exists in multiple IRR objects
	if [[ ${#ROUTE_ORIGIN[@]} -gt 1 ]]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: route_origin_irr_check() VAR{#ROUTE_ORIGIN[@]} -gt 1 if match"
		fi
		for i in "${ROUTE_ORIGIN[@]}" ; do
			if [[ "$i" = ${ROUTE_ORIGIN[0]} ]]; then
				# ADD DEBUG
				#if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: route_origin_irr_check() [for i loop] $i in {ROUTE_ORIGIN[@]} = {ROUTE_ORIGIN[0] if match"
				#fi
				ALL_SAME_ORIGIN=true
			else
				# ADD DEBUG
				#if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: route_origin_irr_check() [for i loop] $i in {ROUTE_ORIGIN[@]} = {ROUTE_ORIGIN[0] if ELSE"
				#fi
				ALL_SAME_ORIGIN=false
				break
			fi
		done

		if [ $ALL_SAME_ORIGIN == true ] && [ "$INFO" = "1" ]; then
			printf_info "+INFO: All route objects contain origin: $ROUTE_ORIGIN"
		fi

		if [ "$WARNING" = "1" ]; then
			printf_warn "+WARNING: >1 route origin seen in IRR data! Filter generation may be inaccurate!"
			for i in "${!ROUTE_ORIGIN[@]}"; do
				if [ "${ROUTE_ORIGIN["$i"]}" != "$RIR_ORIGIN" ]; then
					printf_warn "+WARNING: ["$i"] Found IRR route: $PREFIX - ORIGIN MISMATCH - ["$ROUTE_SRC"] origin: "${ROUTE_ORIGIN["$i"]}" != RIR OriginAS: "$RIR_ORIGIN""
						if [ "$RIR_FOUND" = "true" ]; then
							printf_warn "+WARNING: ["$i"] IT IS POSSIBLE "${ROUTE_ORIGIN["$i"]}" IS DOING SOMETHING NASTY! -- route should only have origin: $RIR_ORIGIN in IRR!"
							if [ "$RIR_ORIGIN" = "${ROUTE_ORIGIN["$i"]}" ]; then
								printf_warn "+WARNING: ["$i"] It is also very possible that $RIR_ORIGIN is the one with bad IRR data."
							fi
						elif [ "$RIR_FOUND" = "false" ]; then
							printf_warn "+WARNING: ["$i"] route should only have origin: in IRR and without RIR OriginAS, it is ambiguous which is correct!"
							printf_warn "+WARNING: ["$i"] origin specification was not found from RIR and was assumed, perhaps incorrectly, to be $MEMBER"
						fi
				elif  [ "${ROUTE_ORIGIN["$i"]}" = "$RIR_ORIGIN" ]; then
					printf_warn "+WARNING: ["$i"] Found IRR route: $PREFIX - ORIGIN MATCH    - ["$ROUTE_SRC"] origin: "${ROUTE_ORIGIN["$i"]}" == RIR OriginAS: "$RIR_ORIGIN""
				else 
					printf_warn "+WARNING: ["$i"] Found IRR route: $PREFIX - ***DEBUG ORIGIN ELSE**** - route: origin: ["${ROUTE_ORIGIN["$i"]}"] + RIR OriginAS: ["$RIR_ORIGIN"]"
				fi
			done
		fi
	fi
	if [[ ${#ROUTE_ORIGIN[@]} -eq 1 && "$RIR_ORIGIN" != "$MEMBER" ]]; then
		if [ "$WARNING" = "1" ]; then
				printf_warn "+WARNING:  The object with origin: "$MEMBER" appears to be the only way $PREFIX can possibly be"
				printf_warn "+WARNING:  included (via "$AS_SET" member: "$MEMBER")"
				printf_warn "+WARNING:  You need to modify your IRR data for AS-SET "$AS_SET" so you have either:"
				printf_warn "+WARNING:   a) member: <AS-SET which recurses to member: "$RIR_ORIGIN">"
				printf_warn "+WARNING:   b) member: "$RIR_ORIGIN" (less preferable method)"
				printf_warn "+WARNING:  before you delete route: "$PREFIX" with origin: "${ROUTE_ORIGIN["$i"]}" from IRR"
		fi
	fi
	# ADD DEBUG
	printf_inverted "route_origin_irr_check() end"
}

route_mntby_autnum_mntby_check() {
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: route_mntby_autnum_mntby_check() start for $PREFIX"
	#fi
	if [ "$ROUTE_MNT" = "$AUT_MNT" ]; then 
		if [ "$INFO" = "1" ]; then
			printf_info "+INFO: route: mnt-by $ROUTE_MNT and aut-num: mnt-by $AUT_MNT match!"
		fi
	else
		printf_warn "+WARNING: route: mnt-by $ROUTE_MNT DOES NOT MATCH aut-num: mnt-by $AUT_MNT"
		printf_warn "+WARNING: Potential error in IRR data for route: $PREFIX"
	fi
	# ADD DEBUG
	#if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: route_mntby_autnum_mntby_check() end for $PREFIX\n"
	#fi
}	

#### END SECTION: BASH FUNCTIONS

## defaults for input variables
SOURCE="NTTCOM"
AS_SET="$1"
DEBUG="0"

# Parse the command line options
while [[ "$#" -gt 0 ]]; do
    case $1 in
        -c|--chain) INFO_CHAIN="1"; shift 1;;
        -m|--mnt) MY_MNT="$2"; shift 2;;
        -s|--source) SOURCE="$2"; shift 2;;
        -i|--info) INFO=1; shift 1;;
        -w|--warning) WARNING=1; shift 1;;
        --debug) DEBUG=1; shift 1;;
        -h|--help) usage;;
        --) shift; break;;  # End of options
        -*) echo "Unknown option: $1"; usage;;
        *) AS_SET="$1"; shift;;  # Handle positional argument
    esac
done

if [ "$DEBUG" = "1" ]; then
	INFO="1"
	WARNING="1"
elif [ "$INFO" = "1" ]; then
	WARNING="1"
fi

# Ensure required options are set
if [[ -z "$AS_SET" ]]; then
	echo "Error: <as_set_name> is required!"
    	usage
fi

# Initialize variables
## make sure we have standard system stuff and utilies for all necessary commands
### Get the bash version
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking bash version"
fi
bash_version_major="${BASH_VERSINFO[0]}"
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: bash_version_major: [$bash_version_major]"
fi
### Check if the version is less than 5
if (( bash_version_major < 5 )); then
	if [ "$DEBUG" = "1" ]; then
    		printf_debug "DEBUG: bash version is < 5; check failed"
	fi
    echo "ERROR: bash v5 required" && exit 1
else
        if [ "$DEBUG" = "1" ]; then
                printf_debug "DEBUG: bash version not < 5; check succeeded"
        fi
fi

GREP=$(command -v grep)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v grep"
fi
if [ -z "$GREP" ]; then
    echo "ERROR: no command found for grep. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: grep found: [$GREP]"
    fi
fi

AWK=$(command -v awk)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v awk"
fi
if [ -z "$AWK" ]; then
    echo "ERROR: no command found for awk. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: awk found: [$AWK]"
    fi
fi

TR=$(command -v tr)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v tr"
fi
if [ -z "$TR" ]; then
    echo "ERROR: no command found for tr. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: tr found: [$TR]"
    fi
fi

TAIL=$(command -v tail)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v tail"
fi
if [ -z "$TAIL" ]; then
    echo "ERROR: no command found for tail. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: tail found: [$TAIL]"
    fi
fi

UNIQ=$(command -v uniq)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v uniq"
fi
if [ -z "$UNIQ" ]; then
    echo "ERROR: no command found for uniq. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: uniq found: [$UNIQ]"
    fi
fi

if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v whois"
fi

WHOIS=$(command -v whois)
if [ -z "$WHOIS" ]; then
    echo "ERROR: no command found for whois. Please check your path." && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: whois found: [$WHOIS]"
    fi
fi
## Mac default /usr/bin/whois is insufficient
UNAME=$(uname)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: UNAME: [$UNAME]"
fi
if [ "$UNAME" = "Darwin" ]; then
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: UNAME: UNAME [$UNAME] matches Darwin, setting WHOIS to /opt/homebrew/opt/whois/bin/whois"
    fi
    WHOIS="/opt/homebrew/opt/whois/bin/whois"
    if [ ! -f "$WHOIS" ]; then
	if [ "$DEBUG" = "1" ]; then
		printf_debug "DEBUG: whois not found"
	fi
        echo "ERROR: please install whois by running 'brew install whois' and then retry" && usage
    else
	if [ "$DEBUG" = "1" ]; then
                printf_debug "DEBUG: whois found: [$WHOIS]"
        fi
    fi
fi

MLR=$(command -v mlr)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v mlr"
fi
if [ -z "$MLR" ]; then
    echo "ERROR: no command found for mlr. Please check your path or install as required." 
    echo "       See https://miller.readthedocs.io/en/6.13.0/installing-miller/ " && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: mlr found: [$MLR]"
    fi
fi

if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: SOURCE: [$SOURCE]"
    printf_debug "DEBUG: AS-SET: [$AS_SET]"
    printf_debug "DEBUG: INFO: [$INFO]"
    printf_debug "DEBUG: WARNING: [$WARNING]"
    printf_debug "DEBUG: DEBUG: [$DEBUG]"
fi

# Declare the 5 RIRs and their whois servers
declare -A WHOISDB=(
    [AFRINIC]="whois.afrinic.net"
    [APNIC]="whois.apnic.net"
    [ARIN]="whois.arin.net"
    [LACNIC]="whois.lacnic.net"
    [RIPE]="whois.ripe.net"
	[IANA]="whois.iana.org"
)
## function get_member_autnums
get_member_autnums() { grep "^members:" | awk '{print $2}' | tr , '\n' | grep -v "AS-"; }

## function get_member_as_sets
get_member_as_sets() { grep "^members:" | awk '{print $2}' | tr , '\n' | grep "AS-"; }

## function get_l3_members
get_l3_members() { grep -E "^remarks:\s+Level3 members:" | sed -E 's/^remarks:[[:space:]]+Level3 members: //' | tr , '\n'; }

# Track the recursion stack for AS-SET chains
declare -a AS_SET_STACK
declare -a ROUTE_ORIGIN

## function validate_as_set
validate_as_set() {
    local as_set="$1"
    if [ "$DEBUG" = "1" ]; then
	printf_debug "DEBUG: executing validate_as_set() for as-set: [$as_set]"
    fi
    if [[ "$as_set" =~ ^(AS(([0-9]+):AS-.*)|^AS-.*|^AS[0-9]+)$ ]]; then
        if [ "$DEBUG" = "1" ]; then
            printf_debug "DEBUG: validate_as_set() returns 0 for valid format of AS_SET or AUT-NUM: [$as_set]"
        fi
        return 0  # Valid AS_SET or AUT-NUM
    else
        if [ "$DEBUG" = "1" ]; then
            printf_debug "DEBUG: valid_as_set() returns 1 for invalid AS_SET: [$as_set]"
        fi
        return 1  # Invalid AS_SET or AUT-NUM
    fi
}

# Validate AS_SET
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: Validating AS-SET or AUT-NUM"
fi
if ! validate_as_set "$AS_SET"; then
    echo "ERROR: Invalid AS-SET or AUT-NUM format" && usage
fi

# Recurse AS_SET
case "$SOURCE" in
    AFRINIC) IRR="whois.afrinic.net";;
    ALTDB) IRR="whois.altdb.net";;
    APNIC) IRR="whois.apnic.net";;
    ARIN) IRR="rr.arin.net";;
    BELL) IRR="whois.in.bell.ca";;
    BBOI) IRR="irr.bboi.net";;
    CANARIE) IRR="whois.canarie.ca";;
    IDNIC) IRR="irr.idnic.net";;
    JPIRR) IRR="jpirr.nic.ad.jp";;
    LACNIC) IRR="irr.lacnic.net";;
    LEVEL3) IRR="rr.level3.net";;
    NESTEGG) IRR="whois.nestegg.net";;
    NTTCOM) IRR="rr.ntt.net";;
    PANIX) IRR="rrdb.access.net";;
    RADB) IRR="whois.radb.net";;
    REACH) IRR="rr.telstraglobal.net";;
    RIPE) IRR="whois.ripe.net";;
    TC) IRR="whois.bgp.net.br";;
    *) echo "ERROR: Unknown source: $SOURCE" && exit 1;;
esac

# Initialize arrays to track visited objects
declare -A VISITED_AUT_NUMS
declare -A VISITED_AS_SETS
declare -A VISITED_PFX_SRC
declare -A VISITED_PFX

modify_as_chain() {
    local current_chain="$1"
    local member="$2"

    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: 1 modify_as_chain()> blorp AS-SET: ["$AS_SET"]"
        printf_debug "DEBUG: 2 modify_as_chain()> blorp local member: ["$member"]"
        printf_debug "DEBUG: 3 modify_as_chain()> blorp current_as_set_chain: ["$current_as_set_chain"]"
        printf_debug "DEBUG: 4 modify_as_chain()> blorp before if local current_chain: ["$current_chain"]"
    fi

    # Only append member if it's not already in the chain to avoid duplicates
    if [[ ! "$current_chain" =~ (^| )$member($| ) ]]; then
		if [ "$DEBUG" = "1" ]; then
        	printf_debug "DEBUG: 5 modify_as_chain()> if match; modifying"
		fi
        current_chain="$current_chain $member"
		if [ "$DEBUG" = "1" ]; then
			printf_debug "DEBUG: 6 modify_as_chain()> modified current_chain: [$current_chain]"
    	fi
	fi
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: 7 modify_as_chain()> no match - current_chain: [$current_chain]"
        printf_debug "DEBUG: 8 end of modify_as_chain()"
    fi
}

ASS_EXIST_COUNT=0

process_as_sets() {
    local AS_SET="$1"
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: process_as_sets()> start for processing AS-SET: ["$AS_SET"]"
		printf_debug "DEBUG: process_as_sets()> initial AS_SET_STACK[*]: "${AS_SET_STACK[*]}""
		printf_debug "DEBUG: process_as_sets()> initial {AS_SET_STACK}: "${AS_SET_STACK}""
		if [ -z "${current_as_set_chain+x}" ]; then
			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is unset"
		elif [ -n "${current_as_set_chain+x}" ]; then
			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set"
			printf_debug "436 echo..."
			echo "$current_as_set"
			printf_debug "...echo 438"
			#printf_debug "DEBUG: process_as_sets()> current_as_set_chain: [$current_as_set_chain]"
			printf_debug "DEBUG: end of elif"
		elif [ -n "${current_as_set_chain+x}" ] && [ -z "${current_as_set_chain}" ]; then
  			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set but empty"
		else
  			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set and not empty"
		fi

        #printf_debug "DEBUG: process_as_sets()> current_as_set_chain: ["$current_as_set_chain"]\n"
    fi
    local AS_SET="$1"

    # Push the current AS-SET onto the stack
    AS_SET_STACK+=("$AS_SET")
	if [ "$DEBUG" = "1" ]; then
		printf_debug "DEBUG: process_as_sets()> set AS_SET_STACK+="AS_SET" -- AS_SET_STACK[*]: "${AS_SET_STACK[*]}""
	fi

    ASS_EXISTS_COUNT=0

    if [ "$DEBUG" = "1" ]; then
	    printf_debug "DEBUG: process_as_sets()> Generating ASS_IRR_OUT for "$AS_SET" against "$IRR""
	    printf_debug "DEBUG: process_as_sets()> "$WHOIS" -h "$IRR" "$AS_SET""
    fi
    ASS_IRR_OUT=$("$WHOIS" -h "$IRR" "$AS_SET")
    IFS=$' ' read -r -d '' -a ASS_MNT_ARRAY < <(echo "$ASS_IRR_OUT" |
	    awk '/^mnt-by:/ {print $2}' |
	    tr '\n' ' ' && printf '\0')
    IFS=$' ' read -r -d '' -a ASS_SRC_ARRAY < <(echo "$ASS_IRR_OUT" |
	    awk '/^source:/ {print $2}' |
	    tr '\n' ' ' && printf '\0')
    if [ "$DEBUG" = "1" ]; then
	    printf_debug "DEBUG: process_as_sets()> ASS_IRR_OUT: ["$ASS_IRR_OUT"]"
	    printf_debug "DEBUG: process_as_sets()> ASS_MNT_ARRAY[@]: ["${ASS_MNT_ARRAY[@]}"]"
	    printf_debug "DEBUG: process_as_sets()> ASS_SRC_ARRAY[@]: ["${ASS_SRC_ARRAY[@]}"]"
    fi
    if [[ "$ASS_IRR_OUT" = "%  No entries found for the selected source(s)." || \
	    "$ASS_IRR_OUT" = "%% ERROR: One or more selected sources are unavailable." ]]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "DEBUG: process_as_sets()> Object ["$AS_SET"] not found querying "$IRR""
			printf_debug "DEBUG: process_as_sets()> NOT FOUND - ASS_EXISTS_COUNT: ["$ASS_EXISTS_COUNT"]"
		fi
	else
		if [ "$DEBUG" = "1" ]; then
			printf_debug "DEBUG: process_as_sets()> Object ["$AS_SET"] found querying "$IRR""
			printf_debug "DEBUG: process_as_sets()> FOUND - Incrementing ASS_EXISTS_COUNT (was: ["$ASS_EXISTS_COUNT"]"
		fi
		ASS_EXISTS_COUNT="${#ASS_MNT_ARRAY[@]}" 
    fi
    if [ "$DEBUG" = "1" ]; then
                        printf_debug "DEBUG: process_as_sets()> end of for REG in SOURCES: ASS_EXISTS_COUNT: ["$ASS_EXISTS_COUNT"]"
                fi

    if [ "$ASS_EXISTS_COUNT" -gt 1 ]; then	# multiple as-set objects seen
		if [ "$WARNING" = "1" ]; then
			printf "$AS_SET\n"
			printf_warn "WARNING: Too much ass!"
	    	printf_warn "WARNING: as-set: $AS_SET exists "$ASS_EXISTS_COUNT" times across multiple registries:" 
	    for i in "${!ASS_MNT_ARRAY[@]}";  do
		    if [ "$WARNING" = "1" ]; then
				printf_warn "WARNING:  as-set: ["$AS_SET"] mnt-by: ["${ASS_MNT_ARRAY[$i]}"] source: ["${ASS_SRC_ARRAY[$i]}"]"
			fi
	    done
			printf_warn "WARNING: There is no guarantee each AS-SET object contains the same data and expands to same routes!"
	    	printf_warn "WARNING: Unexpected behavior may occur depending on order of IRR evaluation when building filters!"
		fi
		    
			if [ "$DEBUG" = "1" ]; then
			    printf_debug "DEBUG: MY_MNT not set - attempting to parse"
		    fi
		    AUT_IN_ASS=$(echo "$AS_SET" | cut -d':' -f1) 
		    for mntby in "${ASS_MNT_ARRAY[@]}";  do 
			    if [ "$DEBUG" = "1" ]; then
				    printf_debug "DEBUG: top of for mntby loop"
				    printf_debug "DEBUG: AUT_IN_ASS: ["$AUT_IN_ASS"]" 
				    printf_debug "DEBUG: ASS_MNT_ARRAY[@]: ["${ASS_MNT_ARRAY[@]}]""
				    printf_debug "DEBUG: mntby: ["$mntby"]"
			    fi
			    if [[ "$mntby" == *"$AUT_IN_ASS" ]]; then  
				    MY_MNT="$mntby"  
				    if [ "$DEBUG" = "1" ]; then
					    printf_debug "DEBUG: matched mntby with AUT_IN_ASS, MY_MNT now: ["$MY_MNT"]"
				    fi
				    break
			    fi
		    done
	    printf "\n"
    fi

    # reset the trip odometer on ASS_EXISTS_COUNT 
    if [ "$DEBUG" = "1" ]; then 
	    printf_debug "DEBUG: process_as_sets()> exited processing loop for AS_SET: "$AS_SET"" 
	    printf_debug "DEBUG: process_as_sets()> resetting ASS_EXISTS_COUNT to 0"
    fi 
    ASS_EXISTS_COUNT=0

    # GetMembers
    if [ "$DEBUG" = "1" ]; then
	    printf_debug "DEBUG: <process_as_sets()#GetMembers> AS_SET: ["$AS_SET"]"
    fi
    ## aut-num 
    MEMBERS=$("$WHOIS" -h "$IRR" "$AS_SET" | get_member_autnums)
    if [ "$DEBUG" = "1" ]; then
	    printf_debug "DEBUG: <process_as_sets()#aut-num>    |->aut-num MEMBERS: [$(echo "$MEMBERS" | tr '\n' ' ')]" 
    fi
    ## as-set
    MEMBERS_ASS=$("$WHOIS" -h "$IRR" "$AS_SET" | get_member_as_sets)
    if [ "$DEBUG" = "1" ]; then 
	    printf_debug "DEBUG: <process_as_sets()#as-set>     |->as-set MEMBERS_ASS: [$(echo "$MEMBERS_ASS" | tr '\n' ' ')]"
    fi

	if [[ -z "$MEMBERS" && -z "$MEMBERS_ASS" ]]; then 
		if [ "$WARNING" = "1" ]; then
	   		printf_warn "WARNING: AS-SET object $AS_SET not found or contains no members!"
		fi
    	# bail out of this iternation of process_as_sets()
		return
	fi

    current_as_set_chain="${AS_SET_STACK[*]}"
	if [ "$DEBUG" = "1" ]; then
		if [ -z "${current_as_set_chain+x}" ]; then
			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is unset"
		elif [ -n "${current_as_set_chain+x}" ]; then
			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set"
		elif [ -n "${current_as_set_chain+x}" ] && [ -z "${current_as_set_chain}" ]; then
  			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set but empty"
		else
  			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set and not empty"
		fi
	fi

    if [[ -z "$current_as_set_chain" ]]; then 
	    current_as_set_chain="$AS_SET"
    fi

    # Process aut-num members (AS numbers)
    while IFS= read -r MEMBER; do 
	    MEMBER=$(echo "$MEMBER" | tr -d '[:space:][:cntrl:]') 
	    if [[ -z "$MEMBER" ]]; then 
		    continue
	    fi

    # Parse maintainers for the member aut-num 
    AUT_MNT_IRR_OUT=$("$WHOIS" -h "$IRR" "$MEMBER" | grep -e "^mnt-by:\|^source:") 
    # Check for aut-num mnt-by, accounting for possibility of multiple aut-nums with different mnt-by (and mnt-lower)
    IFS=$' ' read -r -d '' -a AUT_MNT_ARRAY < <(echo "$AUT_MNT_IRR_OUT" | 
	    awk '/^mnt-by:/ {print $2}' | tr '\n' ' ' && printf '\0') 
    IFS=$' ' read -r -d '' -a AUT_MNT_SRC_ARRAY < <(echo "$AUT_MNT_IRR_OUT" | 
	    awk '/^source:/ {print $2}' | 
	    tr '\n' ' ' && printf '\0') 
    if [ "$DEBUG" = "1" ]; then 
	    printf_debug "DEBUG: <process_aut_nums> AUT_MNT_IRR_OUT: ["$AUT_MNT_IRR_OUT"]" 
	    printf_debug "DEBUG: <process_aut_nums> AUT_MNT_ARRAY[@]: [${AUT_MNT_ARRAY[@]}]" 
	    printf_debug "DEBUG: <process_aut_nums> AUT_MNT_SRC_ARRAY[@]: ["${AUT_MNT_SRC_ARRAY[@]}"]"
	    printf_debug "DEBUG: <process_aut_nums> MEMBER: $MEMBER"
    fi

	#printf_debug "700 {#AUT_MNT_ARRAY[@]}: "${#AUT_MNT_ARRAY[@]}""
	#printf_debug "701 {#AUT_MNT_SRC_ARRAY[@]}: "${#AUT_MNT_SRC_ARRAY[@]}""
	#printf_debug "702 {AUT_MNT_ARRAY[@]}: "${AUT_MNT_ARRAY[@]}""
	#printf_debug "703 {AUT_MNT_SRC_ARRAY[@]}: "${AUT_MNT_SRC_ARRAY[@]}""

	if [[ "${#AUT_MNT_ARRAY[@]}" -eq 1 && "${#AUT_MNT_SRC_ARRAY[@]}" -eq 1 ]]; then 
	    AUT_MNT=$(echo "${AUT_MNT_ARRAY[0]}" | 
		    awk '{$1=$1};1')
            AUT_MNT_SRC=$(echo "${AUT_MNT_SRC_ARRAY[0]}" | 
		    awk '{$1=$1};1')
            if [ "$DEBUG" = "1" ]; then 
		    	printf_debug "DEBUG: <process_aut_nums> AUT_MNT: ["$AUT_MNT"]" 
		    	printf_debug "DEBUG: <process_aut_nums> AUT_MNT_SRC: ["$AUT_MNT_SRC"]"
	    	fi
    else 
	    ## OUTPUT
	    if [ "$WARNING" = "1" ]; then
			printf "$MEMBER\n"
			printf_warn "+WARNING: Too much member!"
	    	printf_warn "+WARNING: Child within of as-set $AS_SET:"
	    	printf_warn "+WARNING:  member: "$MEMBER" object found in multiple sources:" 
	    	for m in "${!AUT_MNT_ARRAY[@]}"; do
				printf_warn "+WARNING:   [aut-num: "$MEMBER"] object [mnt-by: "${AUT_MNT_ARRAY[$m]}"] [source: "${AUT_MNT_SRC_ARRAY[$m]}"]"
			done
        fi
    fi

    if [ "$DEBUG" = "1" ]; then 
		printf_debug "DEBUG: process_as_sets()> evaluate if MEMBER ~= ^AS-"
	fi
    if [[ "$MEMBER" =~ ^AS- ]]; then 
    	if [ "$DEBUG" = "1" ]; then 
			printf_debug "DEBUG: process_as_sets()> if match"
			printf_debug "DEBUG: process_as_sets()> if match pre-modify current_as_set_chain: ["$current_as_set_chain"]"
			printf_debug "DEBUG: process_as_sets()> if match MEMBER: ["$MEMBER"]"
		fi
	    # Recursively process nested AS-SETs
    	if [ "$DEBUG" = "1" ]; then 
			printf_debug "DEBUG: process_as_sets()> if match - invoking modify_as_chain()"
		fi
            current_as_set_chain=$(modify_as_chain "$current_as_set_chain" "$MEMBER")
    	if [ "$DEBUG" = "1" ]; then 
			printf_debug "DEBUG: process_as_sets()> if match - invoking process_as_sets()"
		fi
            process_as_sets "$MEMBER"
    else
		if [ "$DEBUG" = "1" ]; then 
			printf_debug "DEBUG: process_as_sets()> else match"	
		fi
		# TODO maybe bust this off into process_prefix()
		# Process only if it's a valid aut-num and prefix
        if [ -z "${VISITED_AUT_NUMS[$MEMBER]}" ]; then 
			VISITED_AUT_NUMS["$MEMBER"]=1 
			if [ "$DEBUG" = "1" ]; then
				printf_debug "DEBUG: <process_autnum> IRR: ["$IRR"]" 
				printf_debug "DEBUG: <process_autnum> Fetching routes from source [$SOURCE] where [origin: $MEMBER]"
			fi

		    # Get origin: without SOURCE restriction so we can check for overlapping route objects 
		    # Also strip out RPKI sources we don't care about, at least not currently.  
		    IFS= IRR_OUT=($("$WHOIS" -h "$IRR" "\!g -i origin "$MEMBER"" | 
			    grep -e "^route:\|^source:" | 
			    awk '/^source:/ && /RPKI/ {skip=1; next} skip && /^route:/ {skip=0} /^route:/ {route=$0} /^source:/ && !skip && route != "" {print route; print $0; route=""}')) 
			if [ "$DEBUG" = "1" ]; then
				printf_debug "DEBUG: IRR_OUT: ["$IRR_OUT"]"
			fi

		    IFS=' ' PREFIXES=($(grep -e "^route:" <<< "$IRR_OUT" | 
			    awk '{print $2}' | 
			    uniq | 
			    tr '\n' ' '))

		    IFS= ROUTE_IRR_OUT=($("$WHOIS" -h "$IRR" "\!g -x "$PREFIX"" | 
			    grep -e "^route:\|^origin:\|^mnt-by:\|^source:" | 
			    awk '/^route:/ {route=$0} /^origin:/ {origin=$0} /^mnt-by:/ {mntby=$0} /^source:/ {source=$0; if (source !~ /RPKI/) {print route; print origin; if (mntby != "") print mntby; print source} route=""; origin=""; mntby=""; source=""}'))
		
			if [ ${#PREFIXES[@]} -eq 0 ]; then
				if [ "$DEBUG" = "1" ]; then 
					printf_debug "DEBUG: No prefix origins found for aut-num: ["$MEMBER"] in ["$SOURCE"]"
				fi 
				if [ "$WARNING" = "1" ]; then
					printf_warn "WARNING: $current_as_set_chain member: $MEMBER enumerates no originated routes!"
				fi
				continue
			fi

            for PREFIX in "${PREFIXES[@]}"; do	# begin for PREFIX
                if [ -n "$current_as_set_chain" ] && [ -n "$MEMBER" ] && [ -n "$PREFIX" ]; then
					if [ -z "${VISITED_PFX["$PREFIX"]}" ]; then
						VISITED_PFX["$PREFIX"]=false
					fi
					if [ "$DEBUG" = "1" ]; then
						printf_debug "DEBUG: $PREFIX top of for PREFIX loop"
						printf_debug "DEBUG: for PREFIX loop PREFIX: $PREFIX"
						printf_debug "DEBUG: for PREFIX loop VISITED_PFX[PREFIX]: "${VISITED_PFX["$PREFIX"]}""
						printf_debug "DEBUG: determine the origin, mnt-by, and source for route: ["$PREFIX"]"
					fi
					# Collect origin, mnt-by, and source for the current prefix route: and store it
					IFS= ROUTE_IRR_OUT=($("$WHOIS" -h "$IRR" "\!g -x "$PREFIX"" | grep -e "^route:\|^origin:\|^mnt-by:\|^source:" | awk '/^route:/ {route=$0} /^origin:/ {origin=$0} /^mnt-by:/ {mntby=$0} /^source:/ {source=$0; if (source !~ /RPKI/) {print route; print origin; if (mntby != "") print mntby; print source} route=""; origin=""; mntby=""; source=""}'))
					if [ "$DEBUG" = "1" ]; then
						printf_debug "DEBUG: 702 ROUTE_IRR_OUT: ["$ROUTE_IRR_OUT"]"
					fi
					
					# set AUT_MNT
					AUT_MNT=$(echo "${AUT_MNT_ARRAY[0]}" | awk '{$1=$1};1')
					
					# Count the number of route: objects found in IRR
					IFS=' ' read -r -a ROUTE_QTY <<< $(echo -e "$ROUTE_IRR_OUT" | grep -e "^route:\|^source:" | awk '/^route:/ {route=$0} /^source:/ {source=$0; if (source !~ /RPKI/) {print route} route=""; source=""}' | awk '{print $1}' | tr '\n' ' ')

					# Parse origins from ROUTE_IRR_OUT
					IFS=' '  read -r -a ROUTE_ORIGIN <<< $(echo -e "$ROUTE_IRR_OUT" | awk 'BEGIN {IGNORECASE=1} /^origin:/ {print $2}' | tr '\n' ' ') 
					
					# Parse maintainers from ROUTE_IRR_OUT
					IFS=' ' read -r -a ROUTE_MNT <<< $(echo -e "$ROUTE_IRR_OUT" | awk 'BEGIN {IGNORECASE=1} /^mnt-by:/ {print $2}' | tr '\n' ' ')
					# Parse sources from ROUTE_IRR_OUT
					IFS=' ' read -r -a ROUTE_SRC <<< $(echo -e "$ROUTE_IRR_OUT" | awk 'BEGIN {IGNORECASE=1} /^source:/ {print $2}' | tr '\n' ' ')
					
					if [ "$DEBUG" = "1" ]; then
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_ORIGIN[*]: [${ROUTE_ORIGIN[*]}]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_ORIGIN[@]: ["${ROUTE_ORIGIN[@]}"]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_ORIGIN[i]: [${ROUTE_ORIGIN["$i"]}]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT count ROUTE_ORIGIN[@]: ["${#ROUTE_ORIGIN[@]}"]"
						printf_debug "DEBUG: All ROUTE_ORIGIN values: [${ROUTE_ORIGIN[@]}]"
						printf_debug "DEBUG: All ROUTE_ORIGIN values: [${ROUTE_ORIGIN[@]}]"
						for i in "${!ROUTE_ORIGIN[@]}"; do
  							printf_debug "DEBUG: ROUTE_ORIGIN[%d]: [%s]" "$i" "${ROUTE_ORIGIN[i]}"
						done
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_MNT[@]: ["${ROUTE_MNT[@]}"]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_MNT[i]: ["${ROUTE_MNT["$i"]}"]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_SRC[@]: [${ROUTE_SRC[@]}]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_SRC[i]: [${ROUTE_SRC["$i"]}]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_SRC: [$ROUTE_SRC]"
					fi
					# Check if ROUTE_SRC has already been processed
					for i in "${!ROUTE_SRC[@]}"; do		# begin for i 
						KVP="${PREFIX} ${ROUTE_SRC["$i"]} ${ROUTE_MNT["$i"]}"
						if [ -z "${VISITED_PFX_SRC[$KVP]}" ]; then	# set to integer 0 if length0/not exist
							if [ "$DEBUG" = "1" ]; then
								printf_debug "DEBUG: for i in ROUTE_SRC - VISITED_PFX_SRC[KVP] matches if -z ; setting to integer 0"
							fi
							VISITED_PFX_SRC[$KVP]=0
						fi

					if [ "$DEBUG" = "1" ]; then
						printf_debug "DEBUG: begin for i loop"
						printf_debug "DEBUG: in for i loop PREFIX: ["$PREFIX"]" 
						printf_debug "DEBUG: in for i loop {VISITED_PFX_SRC[@]}: ["${VISITED_PFX_SRC[@]}"]"
						printf_debug "DEBUG: in for i loop i: ["$i"]"
						printf_debug "DEBUG: in for i loop {VISITED_PFX_SRC[i]}: ["${VISITED_PFX_SRC["$i"]}"]"
						printf_debug "DEBUG: in for i loop ROUTE_SRC: ["$ROUTE_SRC"]"
						printf_debug "DEBUG: in for i loop KVP: ["$KVP"]"
						printf_debug "DEBUG: in for i loop VISITED_PFX_SRC[KVP]: "${VISITED_PFX_SRC[$KVP]}"" 
						printf_debug "DEBUG: in for i loop count ROUTE_ORIGIN@*]: ["${#ROUTE_ORIGIN[@]}"]"
						printf_debug "DEBUG: in for i loop ROUTE_ORIGIN[i]: [${ROUTE_ORIGIN["$i"]}]"
					fi

					if [ "${VISITED_PFX_SRC[$KVP]}" = "0" ]; then
						# Check for multiple origins of this route
						for o in "${!ROUTE_ORIGIN[@]}"; do	# begin for o
							KVP="${PREFIX} ${ROUTE_SRC[$o]} ${ROUTE_MNT[$o]}"
							if [ "$DEBUG" = "1" ]; then
								printf_debug "DEBUG: for o loop iteration start"
								printf_debug "DEBUG: in for o loop - Parsing route object KVP: ["$KVP"]"
								printf_debug "DEBUG: in for o loop - VISITED_PFX[PREFIX]: ${VISITED_PFX["$PREFIX"]}"
								printf_debug "DEBUG: in for o loop - ROUTE_ORIGIN[o]: [${ROUTE_ORIGIN[$o]}]"
								printf_debug "DEBUG: in for o loop - ROUTE_MNT[o]: [${ROUTE_MNT[$o]}]"
								printf_debug "DEBUG: in for o loop - ROUTE_SRC[o]: [${ROUTE_SRC[$o]}]"
								printf_debug "DEBUG: in for o loop - AUT_MNT_ARRAY[@]: ["${AUT_MNT_ARRAY[@]}"]"
								printf_debug "DBEUG: in for o loop - MEMBER: [$MEMBER]"
								printf_debug "DEBUG: in for o loop - AUT_MNT: ["$AUT_MNT"]"
							fi
							if [ "${VISITED_PFX_SRC[$KVP]}" = "1" ]; then
								if [ "$DEBUG" = "1" ]; then
									printf_debug "DEBUG: VISITED_PFX_SRC[KVP]=1 ; continue and bail out of (continue) for o - KVP: ["$KVP"]"
								fi
								continue
                        	fi


							
					# WIP TODO Get aut-num(s) for OrgID
					# note to future me: remember that ARIN RDAP for the Org contains 
					# 
					# '.autnums[].handle[0]'
					# for the autnum handle under the OrgID
					#
					# and also:
					# '.networks' like below which specify the origin AS of the particular number resource:
					#
					# {
					#  "handle": "NET-23-169-240-0-1",
					#  "startAddress": "23.169.240.0",
					#  "endAddress": "23.169.240.255",
					#  "ipVersion": "v4",
					#  "name": "NET4-MIDNET-240",
					#  "type": "DIRECT ALLOCATION",
					#  "parentHandle": "NET-23-0-0-0-0",
					#  "events": [
					#    {
					#      "eventAction": "last changed",
					#      "eventDate": "2024-11-13T19:47:22-05:00"
					#    },
					#    {
					#      "eventAction": "registration",
					#      "eventDate": "2020-11-30T14:51:19-05:00"
					#    }
					#  ],
					#  "links": [
					#    {
					#      "value": "https://rdap.arin.net/registry/entity/ML-1398",
					#      "rel": "self",
					#      "type": "application/rdap+json",
					#      "href": "https://rdap.arin.net/registry/ip/23.169.240.0"
					#    },
					#    {
					#      "value": "https://rdap.arin.net/registry/entity/ML-1398",
					#      "rel": "alternate",
					#      "type": "application/xml",
					#      "href": "https://whois.arin.net/rest/net/NET-23-169-240-0-1"
					#    }
					#  ],
					#  "port43": "whois.arin.net",
					#  "status": [
					#    "active"
					#  ],
					#  "objectClassName": "ip network",
					#  "cidr0_cidrs": [
					#    {
					#      "v4prefix": "23.169.240.0",
					#      "length": 24
					#    }
					#  ],
					#  "arin_originas0_originautnums": [
					#    16970
					#  ]
					#}
					#

					#WIP
					#if [ "$ARIN_ORG_REF" != "arin_no_match_found" ]; then
					#	ARIN_ORG_AUTNUM="$(curl -s "$ARIN_ORG_REF" | jq -c '.autnums[].handle[0]' | sed s/\"//g)"

							# OUTPUT
							if [ "${VISITED_PFX["$PREFIX"]}" = "true" ]; then	
								continue
							elif [ "${VISITED_PFX["$PREFIX"]}" = "false" ]; then 
								CIDRMASK="${PREFIX##*/}"
								
								do_output
								#route_qty_check - moved to do_output()
								#route_mntby_autnum_mntby_check - moved to do_output()

								# Now determine which scenario matches the data parsed

								if [ "$RIR_ORIGIN" != "$ROUTE_ORIGIN" ]; then	# Found RIR origin but mismatch with route origin - case 4
									PFX_MATCH="c4"
								elif [ "${ROUTE_ORIGIN[$o]}" == "$MEMBER" ] &&  [ "${ROUTE_MNT[$o]}" == "$AUT_MNT" ]; then	# valid data match - case 0
									PFX_MATCH="c0"
								elif [ "${ROUTE_ORIGIN[$o]}" == "$MEMBER" ] && [ "${ROUTE_MNT[$o]}" != "$AUT_MNT" ]; then	# mnt mismatch but will work - case 1
									PFX_MATCH="c1"
                        		elif [ "${ROUTE_ORIGIN[$o]}" != "$MEMBER" ]; then    # origin/member mismatch - bogus IRR objects - case 2
									PFX_MATCH="c2"
								elif [ "${#ROUTE_SRC[@]}" -gt 1 ]; then		# identical route and attributes in multiple registries - case 3
									PFX_MATCH="c3"
								else
									PFX_MATCH="nomatch"
									# CHANGE TO DEBUG
									printf_debug "no case matched for prefix $PREFIX"
								fi

								#is_visited_pfx - moved
								# WIP 
								#moved check_bogons
								#movedrir_query
								route_origin_irr_check
								is_mask_le_24_warning

								if [ "$DEBUG" = "1" ]; then
									printf_debug "DEBUG: end of for o iteration"
								fi
							fi
						done	# end for o
						if [ "$DEBUG" = "1" ]; then
                            printf_debug "DEBUG: end of in for i loop for "[$PREFIX]" + ["$ROUTE_SRC"]"
							printf_debug "DEBUG: VISITED_PFX_SRC[KVP]: ["$VISITED_PFX_SRC[$KVP]"]"
						fi
				fi
		 	done	# end for i
			if [ "$DEBUG" = "1" ]; then
				printf_debug "DEBUG: for i in ROUTE_SRC loop ended"
			fi
		    fi
			unset RIR_ORIGIN
		    if [ "$DEBUG" = "1" ]; then
			    printf_debug "DEBUG: unset RIR_ORIGIN"
			    printf_debug "DEBUG: $PREFIX end of for PREFIX loop"
		    fi
	    done	# end for PREFIX
            fi
        fi
    done <<< "$MEMBERS"

    # Process AS-SET members (AS-SET objects)
    while IFS= read -r MEMBER_ASS; do
        MEMBER_ASS=$(echo "$MEMBER_ASS" | tr -d '[:space:][:cntrl:]')

	# "don't want none unless you got buns, hun!" - Dan
        if [[ -z "$MEMBER_ASS" ]]; then
            continue
        fi

        if [ -n "${VISITED_AS_SETS[$MEMBER_ASS]}" ]; then
		printf "\033[37m\033[44m%-18s %-70s %-10s %-12s \033[1;37m%sWARNING: AS-SET recursion loop!\033[0m\n" \
			"" "$current_as_set_chain" "$MEMBER" "$ROUTE_SRC" ""
		#continue
		return
	fi
        #    echo "ERROR: Circular reference detected for AS-SET: "$MEMBER_ASS""
        #    continue
        #fi

        VISITED_AS_SETS["$MEMBER_ASS"]=1

        # Recursively process nested AS-SETs
        current_as_set_chain=$(modify_as_chain "$current_as_set_chain" "$MEMBER_ASS")
        process_as_sets "$MEMBER_ASS"
    done <<< "$MEMBERS_ASS"

    # Pop the current AS-SET after processing
    if [ "${#AS_SET_STACK[@]}" -gt 0 ]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "DEBUG: unset AS_SET_STACK"
		fi
        unset 'AS_SET_STACK[${#AS_SET_STACK[@]}-1]'
		else
			if [ "$DEBUG" = "1" ]; then
				printf_debug "DEBUG: if AS_SET_STACK eval fell through to else"
			fi
    fi
}

# Start processing from the initial AS-SET
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: Starting with AS-SET: [$AS_SET]"
fi

# Process initial AS-SET and its aut-nums
irr_prefix_count=0
process_as_sets "$AS_SET"
if [ "$DEBUG" = "1" ]; then
	printf_debug "DEBUG: end of iteration for processing initial as-set and aut-nums from AS_SET"
fi
echo "----"
echo "Total prefix count (IRR): $irr_prefix_count"

END_TIME=$(date +%s.%N)
EXEC_TIME=$(echo "$END_TIME - $START_TIME" | bc)
printf "Script execution time: [%.2f secs]\n" "$EXEC_TIME"