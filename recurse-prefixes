#!/usr/bin/env bash

## Copyright (c) 2024 by Adam Korab <adam.korab@sixpackets.com>
## All rights reserved.
##
## This code is maintained by
## Adam Korab 
## and is contributed to by 
## Adam Korab, Dan Gast, Tim Burke, and Swen Wulf
##
## Spiritual inspiration comes from and thanks for supporting work goes to:
## IRR Explorer	(DashCare BV [https://www.dashcare.nl] + Stichting NLNOG [https://www.nlnog.net])
##  [https://irrexplorer.nlnog.net]
##  [https://github.com/nlnog/irrexplorer]
## BGPQ4 (Alexandre Snarskii <snar@snar.spb.ru>)
##  [https://github.com/bgp/bgpq4]

# Usage function to display help message
usage() {
    echo " "
    echo "irr-toolbox:recurse-prefixes - get prefixes by as-set from IRR"
    echo " "
    echo "Recurse a given as-set object through member aut-nums and member as-sets which themselves contain."
    echo "aut-nums, until the end-of-recursion aut-num is reached. Query aut-num objects for originated prefixes."
    echo " "
    echo "Usage: $0 <as_set_name|aut-num> [-s|--source <irr_source> -3|--level3|--lumen] <as_set_name> --debug -h|--help]"
    echo " "
    echo "          <as_set_name|aut-num>        # The IRR object you wish to enumerate"
    echo "          -s|--source <irr_source>     # Name of IRR to query such as NTTCOM, RADB, ALTDB, LEVEL3"
    echo "                                         See https://irr.net/registry for full list of SOURCE options"
    echo "                                         Defaults to NTTCOM if not specified"
    echo "          -3|--level3|--lumen          # Also parse as-set for 'remarks: Level3 members:' and walk"
    echo "                                         recursion for Lumen filtergen, comparing to 'members:' recursion"
    echo "          --debug                      # Enable script debugging output"
    echo "          -h|--help                    # Print this help message and exit"
    echo " "
    exit 1
}

# If no arguments are provided, print usage and exit
if [ $# -eq 0 ]; then
    usage
fi

## defaults for input variables
SOURCE="NTTCOM"
AS_SET="$1"
LUMEN=0
DEBUG=0

# Parse the command line options
while [[ "$#" -gt 0 ]]; do
    case $1 in
        -s|--source) SOURCE="$2"; shift 2;;
        -3|--level3|--lumen) LUMEN=1; shift 1;;
        --debug) DEBUG=1; shift 1;;
        -h|--help) usage;;
        --) shift; break;;  # End of options
        -*) echo "Unknown option: $1"; usage;;
        *) AS_SET="$1"; shift;;  # Handle positional argument
    esac
done

# Ensure required options are set
if [[ -z "$AS_SET" ]]; then
    echo "Error: <as_set_name> is required!"
    usage
fi

# Initialize variables
## make sure we have standard system stuff and utilies for all necessary commands
### Get the bash version
if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: checking bash version"
fi
bash_version_major="${BASH_VERSINFO[0]}"
if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: bash_version_major: [$bash_version_major]"
fi
### Check if the version is less than 5
if (( bash_version_major < 5 )); then
	if [ "$DEBUG" = "1" ]; then
    		echo "DEBUG: bash version is < 5; check failed"
	fi
    echo "ERROR: bash v5 required" && exit 1
else
        if [ "$DEBUG" = "1" ]; then
                echo "DEBUG: bash version not < 5; check succeeded"
        fi
fi

GREP=$(command -v grep)
if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: checking command -v grep"
fi
if [ -z "$GREP" ]; then
    echo "ERROR: no command found for grep. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: grep found: [$GREP]"
    fi
fi
AWK=$(command -v awk)
if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: checking command -v awk"
fi
if [ -z "$AWK" ]; then
    echo "ERROR: no command found for awk. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: awk found: [$AWK]"
    fi
fi
TR=$(command -v tr)
if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: checking command -v tr"
fi
if [ -z "$TR" ]; then
    echo "ERROR: no command found for tr. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: tr found: [$TR]"
    fi
fi
TAIL=$(command -v tail)
if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: checking command -v tail"
fi
if [ -z "$TAIL" ]; then
    echo "ERROR: no command found for tail. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: tail found: [$TAIL]"
    fi
fi

BGPQ4=$(command -v bgpq4)
if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: checking command -v bgpq4"
fi
if [ -z "$BGPQ4" ]; then
    echo "ERROR: no command found for bgpq4. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: bgpq4 found: [$BGPQ4]"
    fi
fi

if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: checking command -v whois"
fi
WHOIS=$(command -v whois)
if [ -z "$WHOIS" ]; then
    echo "ERROR: no command found for whois. Please check your path." && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: whois found: [$WHOIS]"
    fi
fi
## Mac default /usr/bin/whois is insufficient
UNAME=$(uname)
if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: UNAME: [$UNAME]"
fi
if [ "$UNAME" = "Darwin" ]; then
    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: UNAME: UNAME [$UNAME] matches Darwin, setting WHOIS to /opt/homebrew/opt/whois/bin/whois"
    fi
    WHOIS="/opt/homebrew/opt/whois/bin/whois"
    if [ ! -f "$WHOIS" ]; then
	if [ "$DEBUG" = "1" ]; then
		echo "DEBUG: whois not found"
	fi
        echo "ERROR: please install whois by running 'brew install whois' and then retry" && usage
    else
	if [ "$DEBUG" = "1" ]; then
                echo "DEBUG: whois found: [$WHOIS]"
        fi
    fi
fi

if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: SOURCE: [$SOURCE]"
    echo "DEBUG: AS-SET: [$AS_SET]"
    echo "DEBUG: LUMEN: [$LUMEN]"
    echo "DEBUG: DEBUG: [$DEBUG]"
fi

## function get_member_autnums
get_member_autnums() { grep "^members:" | awk '{print $2}' | tr , '\n' | grep -v "AS-"; }

## function get_member_as_sets
get_member_as_sets() { grep "^members:" | awk '{print $2}' | tr , '\n' | grep "AS-"; }

## function get_l3_members
get_l3_members() { grep -E "^remarks:\s+Level3 members:" | sed -E 's/^remarks:[[:space:]]+Level3 members: //' | tr , '\n'; }

# Track the recursion stack for AS-SET chains
declare -a AS_SET_STACK

## function validate_as_set
validate_as_set() {
    local as_set="$1"
    if [ "$DEBUG" = "1" ]; then
	echo "DEBUG: executing validate_as_set() for as-set: [$as_set]"
    fi
    if [[ "$as_set" =~ ^(AS(([0-9]+):AS-.*)|^AS-.*|^AS[0-9]+)$ ]]; then
        if [ "$DEBUG" = "1" ]; then
            echo "DEBUG: validate_as_set() returns 0 for valid format of AS_SET or AUT-NUM: [$as_set]"
        fi
        return 0  # Valid AS_SET
    else
        if [ "$DEBUG" = "1" ]; then
            echo "DEBUG: valid_as_set() returns 1 for invalid AS_SET: [$as_set]"
        fi
        return 1  # Invalid AS_SET or AUT-NUM
    fi
}

# Validate AS_SET
if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: Validating AS-SET or AUT-NUM"
fi
if ! validate_as_set "$AS_SET"; then
    echo "ERROR: Invalid AS-SET or AUT-NUM format: [$as-set]" && usage
fi

# Recurse AS_SET
case "$SOURCE" in
    AFRINIC) IRR="whois.afrinic.net";;
    ALTDB) IRR="whois.altdb.net";;
    APNIC) IRR="whois.apnic.net";;
    ARIN) IRR="rr.arin.net";;
    BELL) IRR="whois.in.bell.ca";;
    BBOI) IRR="irr.bboi.net";;
    CANARIE) IRR="whois.canarie.ca";;
    IDNIC) IRR="irr.idnic.net";;
    JPIRR) IRR="jpirr.nic.ad.jp";;
    LACNIC) IRR="irr.lacnic.net";;
    LEVEL3) IRR="rr.level3.net";;
    NESTEGG) IRR="whois.nestegg.net";;
    NTTCOM) IRR="rr.ntt.net";;
    PANIX) IRR="rrdb.access.net";;
    RADB) IRR="whois.radb.net";;
    REACH) IRR="rr.telstraglobal.net";;
    RIPE) IRR="whois.ripe.net";;
    TC) IRR="whois.bgp.net.br";;
    *) echo "ERROR: Unknown source: $SOURCE" && exit 1;;
esac

SOURCES="AFRINIC ALTDB APNIC ARIN BELL BBOI CANARIE IDNIC JPIRR LACNIC LEVEL3 NESTEGG NTTCOM PANIX RADB REACH RIPE TC"

# Initialize arrays to track visited aut-nums and AS-SETs
declare -A VISITED_AUT_NUMS
declare -A VISITED_AS_SETS

modify_as_chain() {
    local current_chain="$1"
    local member="$2"

    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: Modifying AS-SET chain for MEMBER: [$member]"
        echo "DEBUG: Current chain before modification: [$current_chain]"
    fi

    # Only append member if it's not already in the chain to avoid duplicates
    if [[ ! "$current_chain" =~ (^| )$member($| ) ]]; then
        current_chain="$current_chain $member"
    fi

    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: Modified chain: [$current_chain]"
    fi

    echo "$current_chain"
}

process_as_sets() {
    local AS_SET="$1"

    if [ "$DEBUG" = "1" ]; then
        echo "DEBUG: Processing AS-SET: [$AS_SET]"
    fi

    # Push the current AS-SET onto the stack
    AS_SET_STACK+=("$AS_SET")

    # Get members
    MEMBERS=$($WHOIS -h $IRR "$AS_SET" | get_member_autnums)
    MEMBERS_ASS=$($WHOIS -h $IRR "$AS_SET" | get_member_as_sets)

    if [ "$DEBUG" = "1" ]; then
        echo -e "DEBUG: MEMBERS: [$MEMBERS]\n" | tr '\n' ' ' | sed 's/  /\n/'
        echo -e "DEBUG: MEMBERS_ASS: [$MEMBERS_ASS]\n" | tr '\n' ' ' | sed 's/  /\n/'
    fi

    if [[ -z "$MEMBERS" && -z "$MEMBERS_ASS" ]]; then
        echo "ERROR: AS-SET [$AS_SET] either not found in $SOURCE or contains no members."
        return
    fi

    current_as_set_chain="${AS_SET_STACK[*]}"
    if [[ -z "$current_as_set_chain" ]]; then
        current_as_set_chain="$AS_SET"
    fi

    # Process aut-num members (AS numbers)
    while IFS= read -r MEMBER; do
        MEMBER=$(echo "$MEMBER" | tr -d '[:space:][:cntrl:]')

        if [[ -z "$MEMBER" ]]; then
            continue
        fi

        if [[ "$MEMBER" =~ ^AS- ]]; then
            # Recursively process nested AS-SETs
            current_as_set_chain=$(modify_as_chain "$current_as_set_chain" "$MEMBER")
            process_as_sets "$MEMBER"
        else
            # Process only if it's a valid aut-num and prefix
            if [ -z "${VISITED_AUT_NUMS[$MEMBER]}" ]; then
                VISITED_AUT_NUMS["$MEMBER"]=1

                if [ "$DEBUG" = "1" ]; then
                    echo "DEBUG: IRR: ["$IRR"]"
                    echo "DEBUG: Fetching routes from source [$SOURCE] origin: [$MEMBER]"
                fi
		# Get origin: without SOURCE restriction so we can check for overlapping route objects
		# REMOVE the nl when done debugging, dipshit
		IFS= IRR_OUT=($("$WHOIS" -h "$IRR" "\!g -i origin "$MEMBER"" | nl -ba -w2 | grep -e "^.*route:\|^.*source:" |
			# REMOVE the .* when you remove bl
			awk '/^.*route:/ || /^.*source:/ { 
					if ($0 ~ /^source:/ && /RPKI/) next;  # Skip RPKI sources
						print
					}
				')) 

		# REMOVE the nl debugging, and change awk back from $3 to $2, dipshit
		#IFS=' ' PREFIXES=($(grep -e "^route:" <<< "$IRR_OUT" | awk '{print $2}' | tr '\n' ' '))
		IFS=' ' PREFIXES=($(grep -e "^.*route:" <<< "$IRR_OUT" | awk '{print $3}' | tr '\n' ' '))
	
		if [ "$DEBUG" = "1" ]; then
			echo "DEBUG: IRR_OUT: [$IRR_OUT]"
		fi
		
		if [ ${#PREFIXES[@]} -eq 0 ]; then
                    if [ "$DEBUG" = "1" ]; then
                        echo "DEBUG: No prefix origins found for aut-num: ["$MEMBER"] in ["$SOURCE"]"
                    fi
		    echo -e "${current_as_set_chain} $MEMBER <--- WARNING: aut-num has no route/route6 objects matching origin ["$MEMBER"] in ["$SOURCE"]"
                    continue
                fi

                # Print only complete chains and valid prefixes
                for PREFIX in "${PREFIXES[@]}"; do
                    if [ -n "$current_as_set_chain" ] && [ -n "$MEMBER" ] && [ -n "$PREFIX" ]; then
			if [ "$DEBUG" = "1" ]; then
				echo "DEBUG: output loop - PREFIX: ["$PREFIX"] in MEMBER: [$MEMBER], increment counter"
				echo "DEBUG: determine the sources for route object for ["$PREFIX"]"
			fi

#REMOVE .* dipshit
    #/^route:/ {
IFS=' ' ROUTE_SRC=$(echo "$IRR_OUT" | awk '
/^.*route:/ || 
	/^.*source:/ 
	{if ($0 ~ /^.*source:/ && /RPKI/) 
		next;
		print
	}' | awk -v prefix="$PREFIX" -F: '
/^.*route:/ 
{ gsub(/^\s+/, "", $0); 
	if ($0 ~ prefix) { found_route=1; 
		source_found=0; 
		next 
	} 
} 
found_route && NF { 
if ($0 ~ /^.*source:/ && !/RPKI/) 
	{ sub(/^.*source:\s*/, ""); 
		split($0, arr);  
		print arr[1]; 
		source_found=1; 
	} 
} 
found_route && !NF { 
if (!source_found) 
	{ found_route=0; } 
else 
	{ found_route=0; 
		source_found=0; 
	} 
} ' | tr '\n' ' '
)

	    		if [ "$DEBUG" = "1" ]; then
				echo "DEBUG: ROUTE_SRC: [$ROUTE_SRC]"
			fi
			((irr_prefix_count++))  # Increment the prefix counter
			if [ "$DEBUG" = "1" ]; then
				echo "DEBUG: echo for PREFIX: ["$PREFIX"] from IRR: ["$SOURCE"] with attribute [source: "$ROUTE_SRC"]"
			fi
			echo -e "${current_as_set_chain} $MEMBER PREFIX: $PREFIX (route object found in $SOURCE with attribute [source: "$ROUTE_SRC"])"
			if [ "$DEBUG" = "1" ]; then
				echo "DEBUG: irr_prefix_count: [$irr_prefix_count]"
			fi
                    fi
                done
            fi
        fi
    done <<< "$MEMBERS"

    # Process AS-SET members (AS-SET objects)
    while IFS= read -r MEMBER_ASS; do
        MEMBER_ASS=$(echo "$MEMBER_ASS" | tr -d '[:space:][:cntrl:]')

        if [[ -z "$MEMBER_ASS" ]]; then
            continue
        fi

        if [ -n "${VISITED_AS_SETS[$MEMBER_ASS]}" ]; then
            echo "ERROR: Circular reference detected for AS-SET: $MEMBER_ASS"
            continue
        fi

        VISITED_AS_SETS["$MEMBER_ASS"]=1

        # Recursively process nested AS-SETs
        current_as_set_chain=$(modify_as_chain "$current_as_set_chain" "$MEMBER_ASS")
        process_as_sets "$MEMBER_ASS"
    done <<< "$MEMBERS_ASS"

    # Pop the current AS-SET after processing
    if [ "${#AS_SET_STACK[@]}" -gt 0 ]; then
        unset 'AS_SET_STACK[${#AS_SET_STACK[@]}-1]'
    fi
}

# Start processing from the initial AS-SET
if [ "$DEBUG" = "1" ]; then
    echo "DEBUG: Starting with AS-SET: [$AS_SET]"
fi

# Process initial AS-SET and its aut-nums
irr_prefix_count=0
process_as_sets "$AS_SET"
if [ "$DEBUG" = "1" ]; then
	echo "DEBUG: end of iteration for processing initial as-set and aut-nums from AS_SET"
fi
echo "Total prefix count (IRR): $irr_prefix_count"
