#!/usr/bin/env bash

## Copyright (c) 2024 by Adam Korab <adam.korab@sixpackets.com>
## All rights reserved.
##
## This code is maintained by
## Adam Korab 
## and is contributed to by 
## Adam Korab, Dan Gast, Tim Burke, Justin Handa, Swen Wulf
##
## Spiritual inspiration comes from and gratitude for supporting work goes to:
##
## IRR Explorer	(DashCare BV [https://www.dashcare.nl] + Stichting NLNOG [https://www.nlnog.net])
##  [https://irrexplorer.nlnog.net]
##  [https://github.com/nlnog/irrexplorer]
##
## Daniel Austin MBCS for (https://www.dan.me.uk/filtergen)
##
## Job Snijders for his excellent aggregate6 script (https://github.com/job/aggregate6)
##
## Special thanks to Ken Kresha and the rest of the AS2914 crew for igniting my IRR knowledge and
## curiosity, way back a million years ago in the Y2K!

START_TIME=$(date +%s.%N)

# Usage function to display help message
usage() {
    echo " "
    echo "irr-toolbox:recurse-prefixes4 - examine IPv4 prefixes from IRR aut-num or as-set objects"
    echo " "
    echo "Recurse a given as-set object through member aut-nums and member as-sets which themselves contain."
    echo "aut-nums, until the end-of-recursion aut-num is reached. Query aut-num objects for originated prefixes."
    echo "Alternatively, when the given object is an aut-num, enumerate prefixes from route objects specifying that origin AS"
    echo " "
	echo "Uses ANSI colors.  Suggested terminal width is >=120 columns"
	echo " "
    echo "Usage: $0 <as_set_name|aut-num>  -m|--mnt <mnt-by>" 
	echo "                                 -s|--source <irr_source> <as_set_name>"
	echo "                                 -i|--info"
	echo "                                 -w|--warning"
	echo "                                 -c|--chain"
	echo "                                 -q|--quiet"
	echo "                                 --agg"
	echo "                                 --debug"
	echo "                                 -h|--help"
    echo " "
    printf "%-30s %-80s \n" "<as_set_name|aut-num>" "The IRR object you wish to enumerate"
    printf "%-30s %-80s \n" "" "Useful when combined with -i|--info"
    printf "%-30s %-80s \n" "-m|--mnt <mnt-by>" "The name of your maintainer holding *your* as-set, route, and other IRR objects"
    printf "%-30s %-80s \n" "" "Assumed to be the maintainer of the as-set but can be overriden with this flag"
    printf "%-30s %-80s \n" "" "if you have a reason to do so"
    printf "%-30s %-80s \n" "-s|--source <irr_source>" "Restrict object matching based on source: attribute such as NTTCOM, RADB, ARIN"
    printf "%-30s %-80s \n" "" "See https://irr.net/registry for full list of SOURCE options"
    printf "%-30s %-80s \n" "-i|--info"	"Output verbose extra information about the enumerated route objects from the as-set"
    printf "%-30s %-80s \n" "" "Implicitly sets -w|--warning"
    printf "%-30s %-80s \n" "-w|--warning"	"See warnings about possible IRR data issues (without extra output of -i|--info)"
    printf "%-30s %-80s \n" "-c|--chain" "Output IRR data relative to each prefix, e.g., as-set recusion until aut-num for origin"
    printf "%-30s %-80s \n" "-q|--quiet" "Supress all output which is not an enumerated prefix. Useful for generating prefix-lists"
    printf "%-30s %-80s \n" "--agg"	"Do not output the raw prefix list from the as-set."
	printf "%-30s %-80s \n" "" "Instead, run it though aggregate6 for prefix aggregation first"
    printf "%-30s %-80s \n" "" "Requires python3 venv and will create one in ./.venv_irr-toolbox"
    printf "%-30s %-80s \n" "" "Do not use this flag in modes other than normal output - that is, cannot combine with -i|-w|-c"
    printf "%-30s %-80s \n" "--debug" "Enable script execution debugging - there is a prodigious amount"
    printf "%-30s %-80s \n" "" "of output; use judiciously and don't say we didn't warn you."
    printf "%-30s %-80s \n" "" "Implicitly sets -i|--info and -w|--warning"
    printf "%-30s %-80s \n" "-h|--help" "# Print this help message and exit"
    printf "\n"
    exit 1
}

# If no arguments are provided, print usage and exit
if [ $# -eq 0 ]; then
    usage
fi

## Colors and Backgrounds

red="\e[0;91m"
blue="\e[0;94m"
yellow="\e[33m"
expand_bg="\e[K"
blue_bg="\e[0;104m${expand_bg}"
red_bg="\e[0;101m${expand_bg}"
green_bg="\e[0;102m${expand_bg}"
inverted="\e[7m${expand_bg}"
red_bg_bold_white="\e[1;37m\e[41m${expand_bg}"
green="\e[0;92m"
white="\e[0;97m"
bold="\e[1m"
uline="\e[4m"
blink="\e[5m"
reset="\e[0m"

### BEGIN SECTION: DATABASES

## BOGONDB START
# Suck in the bogons db 
BOGONDB=()
while IFS= read -r bogondb_line; do
    BOGONDB+=("$bogondb_line")
done < "bogon-bn-nonagg.txt"
## BOGONDB END

## IANA_DB START

# Initialize the IANA_DB array to store the processed records
IANA_DB=()
IANA_SRC_FILE="IANA-ipv4-address-space.txt"

# Use grep to filter lines matching the prefix pattern, then pipe to while
while IFS= read -r line; do
    # Extract and clean the prefix by removing leading zeros but keeping "0" when the prefix is 0/8
    iana_prefix=$(echo "$line" | awk '{print $1}' | sed 's/^0*\([1-9][0-9]*\)/\1/' | sed 's/^0*\//0\//')
    
    # Extract designation (fields until a date in YYYY-MM format is found)
    iana_designation=$(echo "$line" | awk '{for (i=2; i<=NF; i++) {if ($i ~ /^[0-9]{4}-[0-9]{2}$/) break; printf "%s ", $i} print ""}' | sed 's/[[:space:]]*$//')
    
    # Extract WHOIS (if present, matches "whois.*")
    iana_whois=$(echo "$line" | awk '{for (i=2; i<=NF; i++) if ($i ~ /^whois\./) {print $i; exit}}')
    
    # Extract the status (always the last field)
    iana_status=$(echo "$line" | awk '{print $NF}')
    
    # Build the row without padding whitespace
    row="$(printf "%s|%s|%s|%s" "$iana_prefix" "$iana_designation" "$iana_whois" "$iana_status")"
    IANA_DB+=("$row")
done < <(grep -E '^[[:space:]]*[0-9]{1,3}/8' "$IANA_SRC_FILE")

# To view the array content
#for row in "${IANA_DB[@]}"; do
#    echo "row: $row"
#done

## IANA_DB END

## AUTNUM_DB START

# WIP

IANA_ASN_DB=()
IANA_ASN_SRC_FILE="IANA-as-numbers.txt"

## AUTNUM_DB END

#### END SECTION: DATABASES

#### BEGIN SECTION: BASH FUNCTIONS

printf_debug() {
	printf "${white}$1${reset}\n"
}

printf_info() {
	printf "${yellow}$1${reset}\n"
}

printf_info_bold () {
	printf "${yellow}${bold}$1${reset}\n"
}

printf_warn() {
	printf "${red_bg_bold_white}$1${reset}\n"
}

printf_inverted() {
	printf "${inverted}$1${reset}\n"
}

is_visited_pfx() {
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: is_visited_pfx start for $PREFIX"
	fi

	if [ ${VISITED_PFX["$PREFIX"]} = "false" ]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: is_visited_pfx() $PREFIX - match if VISITED_PFX[PREFIX]=false - eval to: "${VISITED_PFX["$PREFIX"]}""
			printf_debug "+DEBUG: is_visited_pfx() $PREFIX - counter++ now"
			printf_debug "+DEBUG: is_visited_pfx() $PREFIX visited was false - now we set it to true based on *this* iteration"
		fi
		((irr_prefix_count++))  # Increment the prefix counter
		VISITED_PFX["$PREFIX"]=true
	elif [ ${VISITED_PFX["$PREFIX"]} = "true" ]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: is_visited_pfx() $PREFIX - match elif VISITED_PFX[PREFIX]=true - eval to "${VISITED_PFX["$PREFIX"]}""
			printf_debug "+DEBUG: is_visited_pfx() $PREFIX - match elif - do not increment counter"
		fi
		if [ "$INFO" = "1" ]; then
			printf_info "+INFO: is_visited_pfx(): Already encountered $PREFIX - not incrementing unique prefix count"	
		fi
	fi

	# ADD DEBUG	
	if [ "$DEBUG" = "1" ]; then
		printf_debug "+DEBUG: is_visited_pfx() $PREFIX - irr_prefix_count: "$irr_prefix_count""
		printf_inverted "+DEBUG: is_visited_pfx end for $PREFIX"
	fi
}

conditional_supression() {
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: conditional_supression() start for $PREFIX"
	fi
	SUPPRESSED="0"
	RIR_Suppressed="0"
	if [[ $PREFIX =~ ^44. ]]; then
		if [ "$INFO" = "1" ]; then
			printf_info "+INFO: 44net prefix detected, suppressing proxy reg warning because you can't create RIR route objects"
			printf_info "+INFO: for 44net prefixes and they're often proxy registered for inclusion in filter prefix-lists, which"
			printf_info "+INFO: is usually done by another mntner in a non-RIR registry"
		fi
		SUPPRESSED="1"
		RIR_Suppressed="1"
		RIR_ORIGIN="$MEMBER"
	elif [[ "${ROUTE_MNT[$o]}" = "MAINT-AS20473" && "${ROUTE_SRC[$o]}" = "RADB" ]]; then
		if [ "$INFO" = "1" ]; then
			printf_info "+INFO: Suppressing mnt-by mismatch warning because it's Vultr in RADB, and that's just how they do things :("
		fi
		SUPPRESSED="1"
	fi
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: conditonal_supression() end for $PREFIX"
	fi
}

is_mask_le_24_warning() {
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: is_mask_le_24_warning() start for $PREFIX"
	fi
	if (( CIDRMASK > 24 )) && [ "$WARNING" = "1" ]; then
		printf_warn "+WARNING: Mask length >24.  This will not be accepted in global tables and may be inappropriate in filter lists!"
	elif [ "$INFO" = "1" ]; then
		printf_info "+INFO: Prefix length $CIDRMASK acceptable for global BGP" 
	fi
	#ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: is_mask_le_24_warning() end for $PREFIX"
	fi
}

check_bogons() {
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: check_bogons() start for $PREFIX"
	fi

	# First, unset IS_BOGON from previous run, if any
	unset IS_BOGON

    ## There's some convoluted bitwise and hex value handling in this function.
    ## Blame MS Visual Studio Code, it complained mightily about the first 4 ways I wrote this
    ## and broke syntax highlighting through the rest of the script. Sorry. :(

    local base_ip=${PREFIX%%/*}  # Extract base IP from $PREFIX
    local bogon_match=0  # Flag to track if a match is found

    for bogon in "${BOGONDB[@]}"; do
        local bogon_base=${bogon%%/*}
        local bogon_len=${bogon#*/}

        # Convert the prefix's base IP to a 32-bit decimal
        local a b c d
        IFS=. read -r a b c d <<<"${base_ip}"
        local base_dec=$(( (a * 256**3) + (b * 256**2) + (c * 256) + d ))

        # Convert the bogon base IP to a 32-bit decimal
        local e f g h
        IFS=. read -r e f g h <<<"${bogon_base}"
        local bogon_dec=$(( (e * 256**3) + (f * 256**2) + (g * 256) + h ))

        # Calculate the shift value and mask for the range
        local shift=$((32 - bogon_len))

        # Manually construct the mask by shifting the bits in multiple steps
        local mask_part1=$((0xFFFFFFFF))  # Full 32-bit mask
        local mask=$((mask_part1 << shift))  # Apply the shift
		
		## Leaving the next two commented lines in there because it unfucks the syntax highlighter
        # Alternatively, without hexadecimal:
        # local mask=$(( ((1 << 32) - 1) << shift ))

        # Check if the prefix falls within a bogon range
        if (( (base_dec & mask) == (bogon_dec & mask) )); then
			IS_BOGON=1		# Is bogon
            break 
        elif (( (base_dec & mask) != (bogon_dec & mask) )); then
            IS_BOGON=0		# Is NOT bogon
        else
            printf_inverted "ERROR: check_bogons() else - corner case encountered for $PREFIX"
			exit 1
        fi
    done
	if [ "$INFO" = "1" ]; then
		if [ "$IS_BOGON" = "0" ]; then
			printf_info "+INFO: Not part of known bogon space"
		elif [ "$IS_BOGON" = "1"  ]; then
			printf_warn "+WARNING: $PREFIX is within bogon space and route: $PREFIX should not be found in IRR"
		else
			printf_debug "+ERROR: Bogon status evaluation has failed!"
		fi
	fi
	# ADD DEBUG
	if [ "DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: check_bogons() end for $PREFIX\n"
	fi
}

cidr_to_binary() {
    local cidr=$1
    python3 -c "
import ipaddress
cidr = ipaddress.IPv4Network('$cidr', strict=False)
print(int(cidr.network_address), int(cidr.netmask))
"
}

is_parent_prefix() {
    local parent=$1
    local child=$2

    # Use Python to determine if the child is within the parent
    python3 -c "
import ipaddress
parent = ipaddress.IPv4Network('$parent', strict=False)
child = ipaddress.IPv4Network('$child', strict=False)

if child.subnet_of(parent):
    print('True')
else:
    print('False')
" | grep -q 'True' && return 0 || return 1
}

is_prefix_in_cidr() {
    local prefix=$1
    local cidr=$2

    # Check if the prefix is within the CIDR
    if is_parent_prefix "$cidr" "$prefix"; then
        return 0  # True (match found)
    else
        return 1  # False (no match)
    fi
}

## TODO as_rir_query()

rir_query() {
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: rir_query() start for $PREFIX"
	fi

	# Clear RIR_ORIGIN from previous run, if any
	unset RIR_ORIGIN

	# Get first octet from prefix
	IANA_SLASH8="$(echo "$PREFIX" | cut -d '.' -f1)/8"
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_debug "+DEBUG: rir_query() PREFIX: [$PREFIX] IANA_SLASH8: [$IANA_SLASH8]"
	fi

    for line in "${IANA_DB[@]}"; do
        # Split the entry into individual components
        IFS='|' read -r iana_prefix iana_designation iana_whois iana_status <<< "$line"
		# Check if the current entry matches the IANA_SLASH8.  If it does:
        if [[ $iana_prefix == "$IANA_SLASH8" ]]; then
			# ADD RIR DEBUG
			if [ "$DEBUG" = "1" ]; then
				printf_debug "+DEBUG: rir_query() iana_prefix: [$iana_prefix] == IANA_SLASH8: [$IANA_SLASH8]"
				printf_debug "+DEBUG: rir_query() iana_status: [$iana_status]"
				printf_debug "+DEBUG: rir_query() iana_whois: [$iana_whois]"
			fi

            # If the status is RESERVED, set RIR_BOGON=1 and exit immediately
            if [[ $iana_status == "RESERVED" ]]; then
                printf_inverted "rir_query() IANA status=RESERVED - is bogon"
                break
			fi

            # If not a bogon, eval status for ALLOCATED or LEGACY
            if [[ $iana_status == "ALLOCATED" || $iana_status == "LEGACY" ]]; then
				# If status matches, look at iana_whois to set the appropriate RIR
                if [[ $iana_whois == *"apnic"* ]]; then
                    RIR="APNIC"
                elif [[ $iana_whois == *"ripe"* ]]; then
                    RIR="RIPE"
                elif [[ $iana_whois == *"arin"* ]]; then
                    RIR="ARIN"
                elif [[ $iana_whois == *"afrinic"* ]]; then
                    RIR="AFRINIC"
                elif [[ $iana_whois == *"lacnic"* ]]; then
                    RIR="LACNIC"
                else
                    printf_inverted "+ERROR: RIR match failure for $PREFIX"
					RIR="RIR-ERROR-NO-MATCH-FOUND"
                fi
			else
				printf_warn "+ERROR: rir_query() no iana_status match"
            fi
			
            # Exit loop after evaluating the matching line
            break
		else
			if [ "$DEBUG" = "1" ]; then
				printf_debug "+DEBUG: rir_query() iana_prefix: [$iana_prefix]"
				printf_debug "+DEBUG: rir_query() iana_prefix == IANA_SLASH8: [$IANA_SLASH8] - no match!"
			fi
        fi
    done
	if [ "$INFO" = "1" ]; then
		printf_info "+INFO: Found IPv4 (IANA specified) RIR: $RIR"
	fi

	# query the identified RIR

### START OF LEGACY SANITY CHECK
	# First, check for LEGACY because if so IANA may be wrong and we have to check things manually
	if [[ "$INFO" = "1" && "$iana_status" == "LEGACY" && "$RIR_Suppressed" = "1" ]]; then
		printf_info "+INFO: Status LEGACY RIR check suppressed by prefix matching rule"
	elif [[ "$INFO" = "1" && "$iana_status" == "LEGACY" && "$RIR_Suppressed" = "0" ]]; then
		printf_info_bold "+INFO: IANA LEGACY status, so RIR: $RIR could be a lie. Have to check the other registries now"
	fi

	if [[ "$INFO" == "1" && "$iana_status" == "LEGACY" && "$RIR_Suppressed" = "0" ]]; then
		# ADD DEBUG 
		if [ "$DEBUG" = "1" ]; then
		 	printf_debug "DEBUG: rir_query() iana_status=LEGACY matched - unset FoundTheMonkeys"
		fi
		unset FoundTheMonkeys

		# Query all the fuckin' RIR whois I guess...

		# LEGACY AFRINIC
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: whois AFRINIC $PREFIX"
			printf_debug "+DEBUG: AFRINIC_inetnum: $AFRINIC_inetnum"
		fi
		AFRINIC_inetnum=$(whois -h whois.afrinic.net $PREFIX | awk '/^inetnum:/ { $1=""; print substr($0, 2) }')
		if [ "$AFRINIC_inetnum" == "0.0.0.0 - 255.255.255.255" ]; then
			FoundTheMonkeys=0
			# ADD DEBUG
			#if [ "$DEBUG" = "1" ]; then
				printf_debug "+DEBUG: Received not-my-monkeys from AFRINIC"
			#fi
		else
			FoundTheMonkeys=1
			# ADD DEBUG
			#if [ "$DEBUG" = "1" ]; then
				printf_debug "DEBUG: Received is-my-monkeys from AFRINIC"
			#fi
		fi
		unset AFRINIC_inetnum

		# LEGACY ARIN
		if [ "$FoundTheMonkeys" = "0" ]; then
			baseNet=${PREFIX%%/*}
			ARIN_NetType=$(whois -h whois.arin.net $baseNet | awk '/^NetType:/ { $1=""; print substr($0, 2) }')
			if [ "$DEBUG" = "1" ]; then
				printf_debug "+DEBUG: whois ARIN baseNet: $baseNet"
				printf_debug "+DEBUG: ARIN_NetType: $ARIN_NetType"
			fi
			if [[ "$ARIN_NetType" == "Allocated to ARIN" || "$ARIN_NetType" == "Direct Allocation" ]]; then
				FoundTheMonkeys=1
				RIR="ARIN"
				# ADD DEBUG
				#if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: Received is-my-monkeys from ARIN"
				#fi
				if [ "$INFO" = "1" ]; then
					printf_info "+INFO: IANA LEGACY: found RIR $RIR by direct whois match"
				fi
			else
				FoundTheMonkeys=0
				# ADD DEBUG
				#if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: Received not-my-monkeys from ARIN"
				#fi
			fi
			unset ARIN_NetType
		fi
		
		# LEGACY RIPE
		if [ "$FoundTheMonkeys" = "0" ]; then
			RIPE_netname=$(whois -h whois.ripe.net $PREFIX | awk '/^netname:/ { $1=""; print substr($0, 2) }')
			# ADD DEBUG
			#if [ "$DEBUG" = "1" ]; then
				printf_debug "+DEBUG whois RIPE $PREFIX"
				printf_debug "+DEBUG: RIPE_netname: $RIPE_netname"
			#fi
			if [ "$RIPE_netname" != "NON-RIPE-NCC-MANAGED-ADDRESS-BLOCK" ]; then
				FoundTheMonkeys=1
				RIR="RIPE"
				# ADD DEBUG
				#if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: Received is-my-monkeys from RIPE"
					printf_debug "+DEBUG: RIPE_netname: $RIPE_netname"
				#fi
				if [ "$INFO" = "1" ]; then
					printf_info "+INFO: IANA LEGACY: found RIR $RIR by direct whois match"
				fi
			else
				FoundTheMonkeys=0
				# ADD DEBUG
				#if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: Received not-my-monkeys from RIPE"
				#fi
			fi
			unset RIPE_netname
		fi

	# LEGACY  APNIC
		if [ "$FoundTheMonkeys" = "0" ]; then
			APNIC_netname=$(whois -h whois.apnic.net $PREFIX | awk '/^netname:/ { $1=""; print substr($0, 2) }')
			# ADD DEBUG
			if [ "$DEBUG" = "1" ]; then
				printf_debug "+DEBUG whois APNIC $PREFIX"
				printf_debug "+DEBUG: APNIC_netname: $APNIC_netname"
			fi
			if [ "$APNIC_netname" != "ERX-NETBLOCK" ]; then
				FoundTheMonkeys=1
				RIR="APNIC"
				# ADD DEBUG
				#if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: Received is-my-monkeys from APNIC"
					printf_debug "+DEBUG: APNIC_netname: $APNIC_netname"
				#fi
				if [ "$INFO" = "1" ]; then
					printf_info "+INFO: IANA LEGACY: found RIR $RIR by direct whois match"
				fi
			else
				FoundTheMonkeys=0
				# ADD DEBUG
				#if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: Received not-my-monkeys from APNIC"
				#fi
			fi
			unset APNIC_netname
		fi

		if [ "$FoundTheMonkeys" = "0" ]; then
			printf_inverted "ERROR: FoundTheMonkeysStill is 0"
		fi
	# this closes if iana_status = LEGACY
	fi
### END OF LEGACY SANITY CHECK

	if [[ "$RIR" = "ARIN" && "$RIR_Suppressed" == "0" ]]; then
		baseNet=${PREFIX%%/*}
		# Parent CIDR(s)
		#ARIN_Fetched_CIDR=$(whois -h whois.arin.net $baseNet | awk '/^CIDR:/ {print $2}')
		#ARIN_Fetched_CIDR=$(whois -h whois.arin.net $baseNet | awk '/^CIDR:/ {gsub(",", " ", $0); for (i=2; i<=NF; i++) print $i}')
		IFS=', ' read -r -a ARIN_Fetched_CIDR <<< "$(whois -h whois.arin.net $baseNet | awk '/^CIDR:/ {gsub(/^CIDR:\s*/, ""); gsub(/\s+/, " "); sub(/^ */, ""); print $0}')"

		if [ "$WARNING" = "1" ]; then
			if [ "$INFO" = "1" ]; then
				printf_info "+INFO: Found ${#ARIN_Fetched_CIDR[@]} CIDRs from ARIN query for $baseNet"
				for i in "${!ARIN_Fetched_CIDR[@]}"; do
					printf_info "+INFO:  ["$i"] "${ARIN_Fetched_CIDR[$i]}""
				done
			fi
			
			for i in "${!ARIN_Fetched_CIDR[@]}"; do
    			if is_prefix_in_cidr "$PREFIX" "${ARIN_Fetched_CIDR[$i]}"; then
					if [ "$INFO" = "1" ]; then
        				printf_info "+INFO: Matched $PREFIX to ARIN CIDR: [$i] "${ARIN_Fetched_CIDR[$i]}""
					fi
					ARIN_Matched_CIDR="${ARIN_Fetched_CIDR[$i]}"
       			 	break  # Stop further evaluation once a match is found
				else
					printf_debug "DEBUG: $PREFIX is not child of [$i] "${ARIN_Fetched_CIDR[$i]}""
    			fi
			done
		fi

		if [ "$ARIN_Matched_CIDR" != "$PREFIX" ]; then
			if [ "$WARNING" = "1" ]; then 
				printf_warn "+WARNING: route: $PREFIX does not match ARIN CIDR: $ARIN_Matched_CIDR"
				printf_warn "+WARNING: This may be innocuous, such as a longer prefix reassigned from the parent CIDR"
				printf_warn "+WARNING: which has not been properly reassigned (SWIP) to $MEMBER"
				printf_warn "+WARNING: Please ensure the prefix length is accurate!"
				printf_warn "+WARNING: If $MEMBER holds the entire $ARIN_Matched_CIDR number resource, please consider:"
				printf_warn "+WARNING:  1) $ROUTE_MNT create or ensure exists: [route: $ARIN_Matched_CIDR]"
				printf_warn "+WARNING:  2) build filter based upon $ARIN_Matched_CIDR le $CIDRMASK"
				printf_warn "+WARNING:  3) $ROUTE_MNT delete from IRR this more specific [route: $PREFIX] object" 
			fi
			if [ "$INFO" = "1" ]; then
				printf_info "+INFO: Querying ARIN for info of covering CIDR $ARIN_Fetched_CIDR instead of $PREFIX"
			fi
			# NetHandle
			ARIN_NET_HANDLE=$(whois -h whois.arin.net "r = $ARIN_Fetched_CIDR" | awk '/^NetHandle:/ {print $2}')
			if [ -z "$ARIN_NET_HANDLE" ]; then
				ARIN_NET_HANDLE="arin_no_nethandle_found"
			fi
			# NetName
			ARIN_NET_NAME=$(whois -h whois.arin.net "r = $ARIN_Fetched_CIDR" | awk '/^NetName:/ {print $2}')
			if [ -z "$ARIN_NET_NAME" ]; then
				ARIN_NET_NAME="arin_no_netname_found"
			fi
			# OrgId
			ARIN_ORG_ID=$(whois -h whois.arin.net "r = $ARIN_Fetched_CIDR" | awk '/^OrgId:/ {print $2}')
			if [ -z "$ARIN_ORG_ID" ]; then
				ARIN_ORG_ID="arin_no_orgid_found"
			fi
			# OriginAS
			ARIN_ORIGINAS=$(whois -h whois.arin.net "r = $ARIN_Fetched_CIDR" | awk '/^OriginAS:/ {print $2}') 
			if [ -z "$ARIN_ORIGINAS" ]; then
				ARIN_ORIGINAS="arin_no_originas_found"
				# Set to member if we can't parse it from RIR
				RIR_ORIGIN=$MEMBER
			else
				if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: ARIN OriginAS found in whois. Setting RIR_ORIGIN from ARIN_ORIGINAS"
				fi
				RIR_ORIGIN=$ARIN_ORIGINAS
			fi	
		else 		## when the prefix in the route object matches the ARIN CIDR
			# NetHandle
			ARIN_NET_HANDLE=$(whois -h whois.arin.net "r = $PREFIX" | awk '/^NetHandle:/ {print $2}')
			if [ -z "$ARIN_NET_HANDLE" ]; then
				ARIN_NET_HANDLE="arin_no_nethandle_found"
			fi
			# NetName
			ARIN_NET_NAME=$(whois -h whois.arin.net "r = $PREFIX" | awk '/^NetName:/ {print $2}')
			if [ -z "$ARIN_NET_NAME" ]; then
				ARIN_NET_NAME="arin_no_netname_found"
			fi
			# OrgId
			ARIN_ORG_ID=$(whois -h whois.arin.net "r = $PREFIX" | awk '/^OrgId:/ {print $2}')
			if [ -z "$ARIN_ORG_ID" ]; then
				ARIN_ORG_ID="arin_no_orgid_found"
			fi
			# OriginAS
			ARIN_ORIGINAS=$(whois -h whois.arin.net "r = $PREFIX" | awk '/^OriginAS:/ {print $2}') 
			if [ -z "$ARIN_ORIGINAS" ]; then
				ARIN_ORIGINAS="arin_no_originas_found"
				# Set to member if we can't parse it from RIR
				RIR_ORIGIN=$MEMBER
			else
				if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: ARIN OriginAS found in whois. Setting RIR_ORIGIN from ARIN_ORIGINAS"
				fi
				RIR_ORIGIN=$ARIN_ORIGINAS
			fi
		fi

		if [ "$INFO" = "1" ]; then
			printf_info "+INFO: ARIN NetHandle: $ARIN_NET_HANDLE" 
			printf_info "+INFO: ARIN NetName: $ARIN_NET_NAME" 
			printf_info "+INFO: ARIN OrgId: $ARIN_ORG_ID"
			printf_info "+INFO: ARIN OriginAS: $ARIN_ORIGINAS"
			if [ "$ARIN_ORIGINAS" = "arin_no_originas_found" ]; then
					printf_info_bold "+INFO: Cannot determine origin AS from $RIR. Assuming $MEMBER (which could be wrong!)"
			fi
		fi
	fi

	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: rir_query() end for $PREFIX"
	fi
}

do_output() {
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: do_output() start for $PREFIX"
	fi
	
	if [ "$INFO_CHAIN" = "1" ]; then	# Print header for INFO_CHAIN
		printf "\n"
		if [ "$Is_Autnum" == "1" ]; then
			printf "%s (origin %s)" "$PREFIX" "$MEMBER"
		else	
			printf "%s (enumerated from %s %s)" "$PREFIX" "$current_as_set_chain" "$MEMBER"
		fi
		printf "\n"
	elif [ "$WARNING" = "1" ]; then		# Print header for WARNING
		printf "\n$PREFIX\n"
	else								# Normal output when INFO|INFO_CHAIN|WARNING are false
		OUTPUT_PREFIX=$(echo "$KVP" | awk '{print $1}')	
		printf "$PREFIX\n"
	fi

	if [ "$WARNING" = "1" ]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: do_output() calling is_mask_le_24_warning"
		fi
		is_mask_le_24_warning
	fi

	if [ "$WARNING" = "1" ]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: do_output() calling conditional_supression()"
		fi
		conditional_supression
	fi

	if [ "$WARNING" = "1" ]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: do_output() calling route_qty_check()"
		fi
		route_qty_check
	fi

	if [ "$WARNING" = "1" ]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: do_output() calling route_mntby_autnum_mntby_check()"
		fi
		route_mntby_autnum_mntby_check
	fi

		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: do_output() calling is_visited_pfx()"
		fi
		is_visited_pfx	

	if [ "$WARNING" = "1" ]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: do_output() calling rir_query()"
		fi
		rir_query
	fi

	if [ "$WARNING" = "1" ]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: do_output() calling check_bogons()"
		fi
		check_bogons
	fi

	if [ "$WARNING" = "1" ]; then
		if [ "DEBUG" = "1" ]; then
			printf_debug "+DEBUG: do_output() calling route_origin_irr_check()"
		fi
		route_origin_irr_check
	fi

	if [ "$INFO" = "1" ]; then
    	printf_info "+INFO: Cumulative unique prefix count: $irr_prefix_count"
	fi

	if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: "$PFX_MATCH" setting VISITED_PFX_SRC[KVP] =1 for ["$KVP"]"
	fi
	VISITED_PFX_SRC[$KVP]=1
	if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: $PREFIX $PFX_MATCH for o loop iteration end"
        printf_debug "DEBUG: $PREFIX unset PFX_MATCH (was: "$PFX_MATCH")"
	fi                                                      
	unset PFX_MATCH
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "DEBUG: do_output() end for $PREFIX"
	fi
}

route_qty_check () {
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: route_qty_check() start for $PREFIX"
	fi
	if [ "$INFO" = "1" ]; then
			printf_info "+INFO: Found "${#ROUTE_QTY[@]}" [route: $PREFIX] object(s) in IRR. 1 is the optimal quantity"
			for i in "${!ROUTE_QTY[@]}"; do
				printf_info "+INFO:  ["$i"] route: $PREFIX source: "${ROUTE_SRC["$i"]}" mnt-by: "${ROUTE_MNT["$i"]}" origin: "${ROUTE_ORIGIN["$i"]}""
			done
			if [ "$SUPPRESSED" = "1" ]; then
				printf_info "+INFO: Suppressed >1 route object warning by rule"
			fi
	fi

	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: route_qty_check() end for $PREFIX\n"
	fi
}

route_origin_irr_check() {
	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: route_origin_irr_check() start for $PREFIX"
		printf_debug "+DEBUG: SUPPRESSED: ["$SUPPRESSED"]"
	fi
	# COLLAPSE TO PREVIOUS
	if [ "$DEBUG" = "1" ]; then
		printf_debug "+DEBUG: route_origin_irr_check() count elements in {#ROUTE_ORIGIN[@]}: ${#ROUTE_ORIGIN[@]}"
	fi
	# if more than one origin: exists in multiple IRR objects
	if [[ ${#ROUTE_ORIGIN[@]} -gt 1 ]]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "+DEBUG: route_origin_irr_check() VAR{#ROUTE_ORIGIN[@]} -gt 1 if match"
		fi
		for i in "${ROUTE_ORIGIN[@]}" ; do
			if [[ "$i" = ${ROUTE_ORIGIN[0]} ]]; then
				if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: route_origin_irr_check() [for i loop] $i in {ROUTE_ORIGIN[@]} = {ROUTE_ORIGIN[0] if match"
				fi
				ALL_SAME_ORIGIN=true
			else
				# ADD DEBUG
				if [ "$DEBUG" = "1" ]; then
					printf_debug "+DEBUG: route_origin_irr_check() [for i loop] $i in {ROUTE_ORIGIN[@]} = {ROUTE_ORIGIN[0] if ELSE"
				fi
				ALL_SAME_ORIGIN=false
				break
			fi
		done

		if [ $ALL_SAME_ORIGIN == true ] && [ "$INFO" = "1" ]; then
			printf_info "+INFO: All route objects contain origin: $ROUTE_ORIGIN"
		fi
		if [ "$SUPPRESSED" = "0" ]; then
			if [ "$WARNING" = "1" ]; then
				printf_warn "+WARNING: >1 route origin seen in IRR data! Filter generation may be inaccurate!"
				for i in "${!ROUTE_ORIGIN[@]}"; do
					if [ "${ROUTE_ORIGIN["$i"]}" != "$RIR_ORIGIN" ]; then
						printf_warn "+WARNING: ["$i"] Found IRR route: $PREFIX - ORIGIN MISMATCH - ["$ROUTE_SRC"] origin: "${ROUTE_ORIGIN["$i"]}" != RIR OriginAS: "$RIR_ORIGIN""
						#if [ "$RIR_FOUND" = "true" ]; then
						if [[ "$RIR_ORIGIN" == AS* ]]; then
							printf_warn "+WARNING: ["$i"] IT IS POSSIBLE "${ROUTE_ORIGIN["$i"]}" IS DOING SOMETHING NASTY! -- route should only have origin: $RIR_ORIGIN in IRR!"
							if [ "$RIR_ORIGIN" = "${ROUTE_ORIGIN["$i"]}" ]; then
								printf_warn "+WARNING: ["$i"] It is also very possible that $RIR_ORIGIN is the one with bad IRR data."
							fi
						else 
							printf_warn "+WARNING: ["$i"] route should only have origin: in IRR and without RIR OriginAS, it is ambiguous which is correct!"
							printf_warn "+WARNING: ["$i"] origin specification was not found from RIR and was assumed, perhaps incorrectly, to be $MEMBER"
						fi
					elif  [ "${ROUTE_ORIGIN["$i"]}" = "$RIR_ORIGIN" ]; then
						printf_warn "+WARNING:    ["$i"] Found IRR route: $PREFIX - ORIGIN MATCH    - ["$ROUTE_SRC"] origin: "${ROUTE_ORIGIN["$i"]}" == RIR OriginAS: "$RIR_ORIGIN""
					else 
						printf_inverted "+ERROR: ["$i"] Found IRR route: $PREFIX - ***DEBUG ORIGIN ELSE**** - route: origin: ["${ROUTE_ORIGIN["$i"]}"] + RIR OriginAS: ["$RIR_ORIGIN"]"
					fi
				done
			fi
		fi
	fi

	if [[ ${#ROUTE_ORIGIN[@]} -eq 1 && "$RIR_ORIGIN" = "$MEMBER" && "$INFO" = "1" ]]; then
		printf_info "+INFO: Only 1 route object seen and IRR origin [${ROUTE_ORIGIN[0]}] matches RIR origin [$RIR_ORIGIN]"
	fi

	# ADD DEBUG
	if [ "$DEBUG" = "1" ]; then
		printf_inverted "+DEBUG: route_origin_irr_check() end for $PREFIX"
	fi
}

route_mntby_autnum_mntby_check() {
	if [ "$DEBUG" = "1" ]; then
		printf_debug "+DEBUG: route_mntby_autnum_mntby_check() start for $PREFIX"
	fi

	# There is no mismatch 
	if [ "$ROUTE_MNT" = "$AUT_MNT" ]; then 
		if [ "$INFO" = "1" ]; then
			printf_info "+INFO:  route: mnt-by $ROUTE_MNT and aut-num: mnt-by $AUT_MNT match!"
		fi
	# Mismatch detected
	elif [ "$ROUTE_MNT" != "$AUT_MNT" ]; then
		# Check for conditional_suppression() flag
		if [ "$SUPPRESSED" = "1" ]; then
			if [ "$INFO" = "1" ]; then
				printf_info "+INFO: route mnt-by and aut-num mnt-by do not match, but warning suppressed by rule"
			fi
		else
		# Throw mismatch warning
			if [ "$WARNING" = "1" ]; then
				printf_warn "+WARNING:  [$i] route: mnt-by [$ROUTE_MNT] DOES NOT MATCH aut-num: $MEMBER mnt-by: [$AUT_MNT]"
				if [ "$ROUTE_MNT" == "MAINT-AS27506" ]; then
					printf_info_bold "++INFO: Crown Castle (AS27506,AS46887) is a known promulgator of IRR bullshit under this mntner"
					printf_info_bold "++INFO: specifying their customer as origin AS rather than adding customer as-sets to AS-CCF."
					printf_info_bold "++INFO: Contact <fiberProvAM@crowncastle.com> for removal and advise the technician to review ticket# CCF22489011"
					printf_info_bold "But make sure that CCF adds members: <your as-set> to AS-CCF first!"
					printf_info_bold "While you are pestering them, convince them to add remarks: Level3 members: for...well, everything."
				fi
			fi
		fi
	fi

	if [ "$DEBUG" = "1" ]; then
		printf_debug "+DEBUG: route_mntby_autnum_mntby_check() end for $PREFIX\n"
	fi
}	

#### END SECTION: BASH FUNCTIONS

## defaults for input variables
#SOURCE="NTTCOM"
AS_SET="$1"
DEBUG="0"
AGG_OUTPUT="0"

# Parse the command line options
while [[ "$#" -gt 0 ]]; do
    case $1 in
        -c|--chain) INFO_CHAIN="1"; shift 1;;
        -q|--quiet) QUIET="1"; shift 1;;
        -m|--mnt) MY_MNT="$2"; shift 2;;
        -s|--source) SOURCE="$2"; shift 2;;
        -i|--info) INFO=1; shift 1;;
        -w|--warning) WARNING=1; shift 1;;
        --agg) AGG_OUTPUT=1; shift 1;;
        --debug) DEBUG=1; shift 1;;
        -h|--help) usage;;
        --) shift; break;;  # End of options
        -*) echo "Unknown option: $1"; usage;;
        *) AS_SET="$1"; shift;;  # Handle positional argument
    esac
done

if [ "$DEBUG" = "1" ]; then
	INFO="1"
	WARNING="1"
fi

if [ "$INFO" = "1" ]; then
	WARNING="1"
fi

# Ensure required options are set
if [[ -z "$AS_SET" ]]; then
	echo "Error: <as_set_name> is required!"
    usage
fi

# Initialize variables
## make sure we have standard system stuff and utilies for all necessary commands
### Get the bash version
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking bash version"
fi
bash_version_major="${BASH_VERSINFO[0]}"
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: bash_version_major: [$bash_version_major]"
fi
### Check if the version is less than 5
if (( bash_version_major < 5 )); then
	if [ "$DEBUG" = "1" ]; then
    		printf_debug "DEBUG: bash version is < 5; check failed"
	fi
    printf_warn "ERROR: bash v5 required" && exit 1
else
        if [ "$DEBUG" = "1" ]; then
                printf_debug "DEBUG: bash version not < 5; check succeeded"
        fi
fi

GREP=$(command -v grep)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v grep"
fi
if [ -z "$GREP" ]; then
    printf_warn "ERROR: no command found for grep. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: grep found: [$GREP]"
    fi
fi

AWK=$(command -v awk)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v awk"
fi
if [ -z "$AWK" ]; then
    printf_warn "ERROR: no command found for awk. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: awk found: [$AWK]"
    fi
fi

TR=$(command -v tr)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v tr"
fi
if [ -z "$TR" ]; then
    printf_warn "ERROR: no command found for tr. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: tr found: [$TR]"
    fi
fi

TAIL=$(command -v tail)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v tail"
fi
if [ -z "$TAIL" ]; then
    echo "ERROR: no command found for tail. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: tail found: [$TAIL]"
    fi
fi

UNIQ=$(command -v uniq)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v uniq"
fi
if [ -z "$UNIQ" ]; then
    echo "ERROR: no command found for uniq. Please check your path" && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: uniq found: [$UNIQ]"
    fi
fi

if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: checking command -v whois"
fi

WHOIS=$(command -v whois)
if [ -z "$WHOIS" ]; then
    echo "ERROR: no command found for whois. Please check your path." && exit 1
else
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: whois found: [$WHOIS]"
    fi
fi
## Mac default /usr/bin/whois is insufficient
UNAME=$(uname)
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: UNAME: [$UNAME]"
fi
if [ "$UNAME" = "Darwin" ]; then
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: UNAME: UNAME [$UNAME] matches Darwin, setting WHOIS to /opt/homebrew/opt/whois/bin/whois"
    fi
    WHOIS="/opt/homebrew/opt/whois/bin/whois"
    if [ ! -f "$WHOIS" ]; then
	if [ "$DEBUG" = "1" ]; then
		printf_debug "DEBUG: whois not found"
	fi
        echo "ERROR: please install whois by running 'brew install whois' and then retry" && usage
    else
	if [ "$DEBUG" = "1" ]; then
                printf_debug "DEBUG: whois found: [$WHOIS]"
        fi
    fi
fi

if [ "$AGG_OUTPUT" = "1" ]; then
	PYTHON3=$(command -v python3)
	if [ "$DEBUG" = "1" ]; then
    	printf_debug "DEBUG: invoked with --agg - checking command -v python3"
	fi
	if [ -z "$PYTHON3" ]; then
    	echo "ERROR: no command found for python3. Please check your path or install as required." && usage
	else
    	if [ "$DEBUG" = "1" ]; then
        	printf_debug "DEBUG: invoked with --agg - python3 found: [$PYTHON3]"
    	fi
	fi
fi

if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: SOURCE: [$SOURCE]"
    printf_debug "DEBUG: AS-SET: [$AS_SET]"
    printf_debug "DEBUG: INFO: [$INFO]"
    printf_debug "DEBUG: WARNING: [$WARNING]"
    printf_debug "DEBUG: CHAIN: [$CHAIN]"
    printf_debug "DEBUG: AGG_OUTPUT: [$AGG_OUTPUT]"
    printf_debug "DEBUG: DEBUG: [$DEBUG]"
fi

# Bail out if -agg is used in a scenario other than default (terse) output
if [ "$DEBUG" = "1" ]; then
	printf_debug "DEBUG: checking sanity of -agg flag with -i|-w|-c"
fi
if [[ "$AGG_OUTPUT" = "1" && ( "$INFO" = "1" || "$INFO_CHAIN" = "1" || "$WARNING" = "1" ) ]]; then
	if [ "$DEBUG" = "1" ]; then
		printf_debug "DEBUG: sanity of -agg flag with -i|-w|-c is insane. Bailing out!"
	fi
	printf "\n"
	printf_warn "ERROR: cannot use -i|-c|-w concurrent with --agg"
	usage
fi

# Declare the 5 RIRs and their whois servers
declare -A WHOISDB=(
    [AFRINIC]="whois.afrinic.net"
    [APNIC]="whois.apnic.net"
    [ARIN]="whois.arin.net"
    [LACNIC]="whois.lacnic.net"
    [RIPE]="whois.ripe.net"
	[IANA]="whois.iana.org"
)
## function get_member_autnums
get_member_autnums() { grep "^members:" | awk '{print $2}' | tr , '\n' | grep -v "AS-"; }

## function get_member_as_sets
get_member_as_sets() { grep "^members:" | awk '{print $2}' | tr , '\n' | grep "AS-"; }

# Track the recursion stack for AS-SET chains
declare -a AS_SET_STACK
declare -a ROUTE_ORIGIN

# Recurse AS_SET
case "$SOURCE" in
    AFRINIC) IRR="whois.afrinic.net";;
    ALTDB) IRR="whois.altdb.net";;
    APNIC) IRR="whois.apnic.net";;
    ARIN) IRR="rr.arin.net";;
    BELL) IRR="whois.in.bell.ca";;
    BBOI) IRR="irr.bboi.net";;
    CANARIE) IRR="whois.canarie.ca";;
    IDNIC) IRR="irr.idnic.net";;
    JPIRR) IRR="jpirr.nic.ad.jp";;
    LACNIC) IRR="irr.lacnic.net";;
    LEVEL3) IRR="rr.level3.net";;
    NESTEGG) IRR="whois.nestegg.net";;
    NTTCOM) IRR="rr.ntt.net";;
    PANIX) IRR="rrdb.access.net";;
    RADB) IRR="whois.radb.net";;
    REACH) IRR="rr.telstraglobal.net";;
    RIPE) IRR="whois.ripe.net";;
    TC) IRR="whois.bgp.net.br";;
    *) IRR="rr.ntt.net";;
esac

# Initialize arrays to track visited objects
declare -A VISITED_AUT_NUMS
declare -A VISITED_AS_SETS
declare -A VISITED_PFX_SRC
declare -A VISITED_PFX

modify_as_chain() {
    local current_chain="$1"
    local member="$2"

    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: modify_as_chain()> AS-SET: ["$AS_SET"]"
        printf_debug "DEBUG: modify_as_chain()> local member: ["$member"]"
        printf_debug "DEBUG: modify_as_chain()> current_as_set_chain: ["$current_as_set_chain"]"
        printf_debug "DEBUG: modify_as_chain()> before if local current_chain: ["$current_chain"]"
    fi

    # Only append member if it's not already in the chain to avoid duplicates
    if [[ ! "$current_chain" =~ (^| )$member($| ) ]]; then
		if [ "$DEBUG" = "1" ]; then
        	printf_debug "DEBUG: modify_as_chain()> if match; modifying"
		fi
        current_chain="$current_chain $member"
		if [ "$DEBUG" = "1" ]; then
			printf_debug "DEBUG: modify_as_chain()> modified current_chain: [$current_chain]"
    	fi
	fi
    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: modify_as_chain()> no match - current_chain: [$current_chain]"
        printf_debug "DEBUG: end of modify_as_chain()"
    fi
}

ASS_EXIST_COUNT=0

process_as_sets() {
    local as_set="$1"
	# Parse the given as-set and figure out if it's an as-set or an aut-num
	if [[ "$as_set" =~ ^[Aa][Ss][0-9]{1,}$ ]]; then
		# ADD DEBUG
		if [ "$DEBUG" == "1" ]; then
    		printf_debug "$AS_SET is an aut-num"
		fi
		Is_AsSet="0"
		Is_Autnum="1"
	elif [[ "$AS_SET" =~ ^[Aa][Ss][0-9]{1,}:[Aa][Ss]-.*$ ]]; then
		# ADD DEBUG
		if [ "$DEBUG" == "1" ]; then
    		printf_debug "$AS_SET is an as-set with an aut-num prefix"
		fi
		Is_AsSet="1"
		Is_Autnum="0"
	elif [[ "$AS_SET" =~ ^[Aa][Ss]-.*$ ]]; then
		# ADD DEBUG
		if [ "$DEBUG" == "1" ]; then
    		printf_debug "$AS_SET is an as-set without an aut-num prefix"
		fi
		Is_AsSet="1"
		Is_Autnum="0"
	else
		if [ "$DEBUG" == "1" ]; then
    		printf_debug "$AS_SET does not match any recognized pattern" && usage
		fi
	fi

    if [ "$DEBUG" = "1" ]; then
        printf_debug "DEBUG: process_as_sets()> start for processing AS-SET: ["$AS_SET"]"
		printf_debug "DEBUG: process_as_sets()> initial AS_SET_STACK[*]: "${AS_SET_STACK[*]}""
		printf_debug "DEBUG: process_as_sets()> initial {AS_SET_STACK}: "${AS_SET_STACK}""
		if [ -z "${current_as_set_chain+x}" ]; then
			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is unset"
		elif [ -n "${current_as_set_chain+x}" ]; then
			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set"
			printf_debug "DEBUG: process_as_sets()> end of elif"
		elif [ -n "${current_as_set_chain+x}" ] && [ -z "${current_as_set_chain}" ]; then
  			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set but empty"
		else
  			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set and not empty"
		fi
    fi

    local AS_SET="$1"
    # Push the current AS-SET onto the stack
    AS_SET_STACK+=("$AS_SET")
	if [ "$DEBUG" = "1" ]; then
		printf_debug "DEBUG: process_as_sets()> set AS_SET_STACK+="AS_SET" -- AS_SET_STACK[*]: "${AS_SET_STACK[*]}""
	fi

    ASS_EXISTS_COUNT=0
    if [ "$DEBUG" = "1" ]; then
	    printf_debug "DEBUG: process_as_sets()> Generating ASS_IRR_OUT for "$AS_SET" against "$IRR""
	    printf_debug "DEBUG: process_as_sets()> "$WHOIS" -h "$IRR" [-s "$SOURCE"] "$AS_SET""
    fi
    
	if [[ -n "$SOURCE" ]]; then
		ASS_IRR_OUT=$("$WHOIS" -h "$IRR" -s "$SOURCE" "$AS_SET")
	else
    	ASS_IRR_OUT=$("$WHOIS" -h "$IRR" "$AS_SET")
	fi

    IFS=$' ' read -r -d '' -a ASS_MNT_ARRAY < <(echo "$ASS_IRR_OUT" |
	    awk '/^mnt-by:/ {print $2}' |
	    tr '\n' ' ' && printf '\0')
    IFS=$' ' read -r -d '' -a ASS_SRC_ARRAY < <(echo "$ASS_IRR_OUT" |
	    awk '/^source:/ {print $2}' |
	    tr '\n' ' ' && printf '\0')
    if [ "$DEBUG" = "1" ]; then
	    printf_debug "DEBUG: process_as_sets()> ASS_IRR_OUT: ["$ASS_IRR_OUT"]"
	    printf_debug "DEBUG: process_as_sets()> ASS_MNT_ARRAY[@]: ["${ASS_MNT_ARRAY[@]}"]"
	    printf_debug "DEBUG: process_as_sets()> ASS_SRC_ARRAY[@]: ["${ASS_SRC_ARRAY[@]}"]"
    fi
    if [[ "$ASS_IRR_OUT" = "%  No entries found for the selected source(s)." || \
	    "$ASS_IRR_OUT" = "%% ERROR: One or more selected sources are unavailable." ]]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "DEBUG: process_as_sets()> Object ["$AS_SET"] not found querying "$IRR""
			printf_debug "DEBUG: process_as_sets()> NOT FOUND - ASS_EXISTS_COUNT: ["$ASS_EXISTS_COUNT"]"
		fi
	else
		if [ "$DEBUG" = "1" ]; then
			printf_debug "DEBUG: process_as_sets()> Object ["$AS_SET"] found querying "$IRR""
			printf_debug "DEBUG: process_as_sets()> FOUND - Incrementing ASS_EXISTS_COUNT (was: ["$ASS_EXISTS_COUNT"]"
		fi
		ASS_EXISTS_COUNT="${#ASS_MNT_ARRAY[@]}" 
    fi
    if [ "$DEBUG" = "1" ]; then
                        printf_debug "DEBUG: process_as_sets()> end of for REG in SOURCES: ASS_EXISTS_COUNT: ["$ASS_EXISTS_COUNT"]"
                fi

    if [ "$ASS_EXISTS_COUNT" -gt 1 ]; then	# multiple as-set objects seen
		if [ "$WARNING" = "1" ]; then
			printf "$AS_SET\n"
			# Too much ass!
	    	printf_warn "+WARNING: as-set: $AS_SET exists "$ASS_EXISTS_COUNT" times across multiple registries:" 
	    for i in "${!ASS_MNT_ARRAY[@]}";  do
		    if [ "$WARNING" = "1" ]; then
				printf_warn "+WARNING:  as-set: ["$AS_SET"] mnt-by: ["${ASS_MNT_ARRAY[$i]}"] source: ["${ASS_SRC_ARRAY[$i]}"]"
			fi
	    done
			printf_warn "+WARNING: There is no guarantee each AS-SET object contains the same data and expands to same routes!"
	    	printf_warn "+WARNING: Unexpected behavior may occur depending on order of IRR evaluation when building filters!"
			printf_warn "+WARNING: You should determine which of these is most correct and remove any others from IRR"
		fi
		    
			if [ "$DEBUG" = "1" ]; then
			    printf_debug "DEBUG: MY_MNT not set - attempting to parse"
		    fi
		    AUT_IN_ASS=$(echo "$AS_SET" | cut -d':' -f1) 
		    for mntby in "${ASS_MNT_ARRAY[@]}";  do 
			    if [ "$DEBUG" = "1" ]; then
				    printf_debug "DEBUG: top of for mntby loop"
				    printf_debug "DEBUG: AUT_IN_ASS: ["$AUT_IN_ASS"]" 
				    printf_debug "DEBUG: ASS_MNT_ARRAY[@]: ["${ASS_MNT_ARRAY[@]}]""
				    printf_debug "DEBUG: mntby: ["$mntby"]"
			    fi
			    if [[ "$mntby" == *"$AUT_IN_ASS" ]]; then  
				    MY_MNT="$mntby"  
				    if [ "$DEBUG" = "1" ]; then
					    printf_debug "DEBUG: matched mntby with AUT_IN_ASS, MY_MNT now: ["$MY_MNT"]"
				    fi
				    break
			    fi
		    done
	    printf "\n"
    fi

    # reset the trip odometer on ASS_EXISTS_COUNT 
    if [ "$DEBUG" = "1" ]; then 
	    printf_debug "DEBUG: process_as_sets()> exited processing loop for AS_SET: "$AS_SET"" 
	    printf_debug "DEBUG: process_as_sets()> resetting ASS_EXISTS_COUNT to 0"
    fi 
    ASS_EXISTS_COUNT=0

    # GetMembers
    if [ "$DEBUG" = "1" ]; then
	    printf_debug "DEBUG: <process_as_sets()#GetMembers> AS_SET: ["$AS_SET"]"
    fi
    ## aut-num 
	if [[ -n "$SOURCE" ]]; then
    	MEMBERS=$("$WHOIS" -h "$IRR" -s "$SOURCE" "$AS_SET" | get_member_autnums)
	else
    	MEMBERS=$("$WHOIS" -h "$IRR" "$AS_SET" | get_member_autnums)
	fi

    if [ "$DEBUG" = "1" ]; then
	    printf_debug "DEBUG: <process_as_sets()#aut-num>    |->aut-num MEMBERS: [$(echo "$MEMBERS" | tr '\n' ' ')]" 
    fi
    ## as-set
	if [[ -n "$SOURCE" ]]; then
    	MEMBERS_ASS=$("$WHOIS" -h "$IRR" -s "$SOURCE" "$AS_SET" | get_member_as_sets)
	else
    	MEMBERS_ASS=$("$WHOIS" -h "$IRR" "$AS_SET" | get_member_as_sets)
	fi
    if [ "$DEBUG" = "1" ]; then 
	    printf_debug "DEBUG: <process_as_sets()#as-set>     |->as-set MEMBERS_ASS: [$(echo "$MEMBERS_ASS" | tr '\n' ' ')]"
    fi

	if [[ -z "$MEMBERS" && -z "$MEMBERS_ASS" && "Is_AsSet" == "1" ]]; then 
		printf_debug "DEBUG: Is_AsSet = $Is_AsSet"
		printf_debug "DEBUG: Is_Autnum = $Is_Autnum"
		if [ "$WARNING" = "1" ]; then
	   		printf_warn "WARNING: AS-SET object $AS_SET not found or contains no members!"
		fi
    	# bail out of this iternation of process_as_sets()
		return
	fi

	if [[ -z "$MEMBERS" && -z "$MEMBERS_ASS" && "$Is_Autnum" == "1" ]]; then 
		if [ "$DEBUG" == "1" ]; then
			printf_debug "DEBUG: is an aut-num - set MEMBERS to itself"
		fi
		MEMBERS="$as_set"
	fi

    current_as_set_chain="${AS_SET_STACK[*]}"
	if [ "$DEBUG" = "1" ]; then
		if [ -z "${current_as_set_chain+x}" ]; then
			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is unset"
		elif [ -n "${current_as_set_chain+x}" ]; then
			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set"
		elif [ -n "${current_as_set_chain+x}" ] && [ -z "${current_as_set_chain}" ]; then
  			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set but empty"
		else
  			printf_debug "DEBUG: process_as_sets()> current_as_set_chain is set and not empty"
		fi
	fi

    if [[ -z "$current_as_set_chain" ]]; then 
	    current_as_set_chain="$AS_SET"
    fi

    # Process aut-num members (AS numbers)
    while IFS= read -r MEMBER; do 
	    MEMBER=$(echo "$MEMBER" | tr -d '[:space:][:cntrl:]') 
	    if [[ -z "$MEMBER" ]]; then 
		    continue
	    fi

    # Parse maintainers for the member aut-num 
	if [[ -n "$SOURCE" ]]; then
		if [ "$DEBUG" == "1" ]; then
			printf_debug "DEBUG: object SOURCE restricted to $SOURCE"
		fi
    	AUT_MNT_IRR_OUT=$("$WHOIS" -h "$IRR" -s "$SOURCE" "$MEMBER" | grep -e "^mnt-by:\|^source:") 
	else
		if [ "$DEBUG" == "1" ]; then
			printf_debug "DEBUG: SOURCE is not set - using all"
		fi
    	AUT_MNT_IRR_OUT=$("$WHOIS" -h "$IRR" "$MEMBER" | grep -e "^mnt-by:\|^source:") 
	fi
    # Check for aut-num mnt-by, accounting for possibility of multiple aut-nums with different mnt-by (and mnt-lower)
    IFS=$' ' read -r -d '' -a AUT_MNT_ARRAY < <(echo "$AUT_MNT_IRR_OUT" | 
	    awk '/^mnt-by:/ {print $2}' | tr '\n' ' ' && printf '\0') 
    IFS=$' ' read -r -d '' -a AUT_MNT_SRC_ARRAY < <(echo "$AUT_MNT_IRR_OUT" | 
	    awk '/^source:/ {print $2}' | 
	    tr '\n' ' ' && printf '\0') 
    if [ "$DEBUG" = "1" ]; then 
	    printf_debug "DEBUG: <process_aut_nums> AUT_MNT_IRR_OUT: ["$AUT_MNT_IRR_OUT"]" 
	    printf_debug "DEBUG: <process_aut_nums> AUT_MNT_ARRAY[@]: [${AUT_MNT_ARRAY[@]}]" 
	    printf_debug "DEBUG: <process_aut_nums> AUT_MNT_SRC_ARRAY[@]: ["${AUT_MNT_SRC_ARRAY[@]}"]"
	    printf_debug "DEBUG: <process_aut_nums> MEMBER: $MEMBER"
    fi

	if [[ "$INFO" = "1" && "$Is_AsSet" == "1" ]]; then			# Print header for INFO
		printf "\n"
	  	printf_info "INFO: Recursing as-set: ["$AS_SET"] mnt-by: ["${ASS_MNT_ARRAY[0]}"] source: ["${ASS_SRC_ARRAY[0]}"]\n"
	fi	

	if [[ "${#AUT_MNT_ARRAY[@]}" -eq 1 && "${#AUT_MNT_SRC_ARRAY[@]}" -eq 1 ]]; then 
	    AUT_MNT=$(echo "${AUT_MNT_ARRAY[0]}" | 
		    awk '{$1=$1};1')
            AUT_MNT_SRC=$(echo "${AUT_MNT_SRC_ARRAY[0]}" | 
		    awk '{$1=$1};1')
            if [ "$DEBUG" = "1" ]; then 
		    	printf_debug "DEBUG: <process_aut_nums> AUT_MNT: ["$AUT_MNT"]" 
		    	printf_debug "DEBUG: <process_aut_nums> AUT_MNT_SRC: ["$AUT_MNT_SRC"]"
	    	fi
    else 
	    ## OUTPUT
	    if [[ "$WARNING" = "1" && "$Is_AsSet" == "1" ]]; then
			# Too much member!
	    	printf_warn "+WARNING: Within [as-set $AS_SET]"
	    	printf_warn "+WARNING:  [member: "$MEMBER"] object found in multiple IRR sources:" 
	    	for m in "${!AUT_MNT_ARRAY[@]}"; do
				printf_warn "+WARNING:   [aut-num: "$MEMBER"] object [mnt-by: "${AUT_MNT_ARRAY[$m]}"] [source: "${AUT_MNT_SRC_ARRAY[$m]}"]"
			done
			printf_warn "+WARNING: You should determine which of these is most correct and remove any others from IRR"
			printf_warn "+WARNING: route mnt-by mismatch errors with aut-num mnt-by will be inaccurate until this is fixed!"
        fi
    fi

    if [ "$DEBUG" = "1" ]; then 
		printf_debug "DEBUG: process_as_sets()> evaluate if MEMBER ~= ^AS-"
	fi
    if [[ "$MEMBER" =~ ^AS- ]]; then 
    	if [ "$DEBUG" = "1" ]; then 
			printf_debug "DEBUG: process_as_sets()> if match"
			printf_debug "DEBUG: process_as_sets()> if match pre-modify current_as_set_chain: ["$current_as_set_chain"]"
			printf_debug "DEBUG: process_as_sets()> if match MEMBER: ["$MEMBER"]"
		fi
	    # Recursively process nested AS-SETs
    	if [ "$DEBUG" = "1" ]; then 
			printf_debug "DEBUG: process_as_sets()> if match - invoking modify_as_chain()"
		fi
            current_as_set_chain=$(modify_as_chain "$current_as_set_chain" "$MEMBER")
    	if [ "$DEBUG" = "1" ]; then 
			printf_debug "DEBUG: process_as_sets()> if match - invoking process_as_sets()"
		fi
            process_as_sets "$MEMBER"
    else
		if [ "$DEBUG" = "1" ]; then 
			printf_debug "DEBUG: process_as_sets()> else match"	
		fi
		# TODO maybe bust this off into process_prefix()
		# Process only if it's a valid aut-num and prefix
        if [ -z "${VISITED_AUT_NUMS[$MEMBER]}" ]; then 
			VISITED_AUT_NUMS["$MEMBER"]=1 
			if [ "$DEBUG" = "1" ]; then
				printf_debug "DEBUG: <process_autnum> IRR: ["$IRR"]" 
				printf_debug "DEBUG: <process_autnum> Fetching routes from source [$SOURCE] where [origin: $MEMBER]"
			fi

		    # Get origin: without SOURCE restriction so we can check for overlapping route objects 
		    # Also strip out RPKI sources we don't care about, at least not currently.  
			if [[ -n "$SOURCE" ]]; then
		    	IFS= IRR_OUT=($("$WHOIS" -h "$IRR" "\!g -s "$SOURCE" -i origin "$MEMBER"" | 
			    	grep -e "^route:\|^source:" | 
			    	awk '/^source:/ && /RPKI/ {skip=1; next} skip && /^route:/ {skip=0} /^route:/ {route=$0} /^source:/ && !skip && route != "" {print route; print $0; route=""}')) 
			else
				IFS= IRR_OUT=($("$WHOIS" -h "$IRR" "\!g -i origin "$MEMBER"" | 
			    	grep -e "^route:\|^source:" | 
			    	awk '/^source:/ && /RPKI/ {skip=1; next} skip && /^route:/ {skip=0} /^route:/ {route=$0} /^source:/ && !skip && route != "" {print route; print $0; route=""}')) 
			fi

			if [ "$DEBUG" = "1" ]; then
				printf_debug "DEBUG: IRR_OUT: ["$IRR_OUT"]"
			fi

		    IFS=' ' PREFIXES=($(grep -e "^route:" <<< "$IRR_OUT" | 
			    awk '{print $2}' | 
			    uniq | 
			    tr '\n' ' '))

		    IFS= ROUTE_IRR_OUT=($("$WHOIS" -h "$IRR" "\!g -x "$PREFIX"" | 
			    grep -e "^route:\|^origin:\|^mnt-by:\|^source:" | 
			    awk '/^route:/ {route=$0} /^origin:/ {origin=$0} /^mnt-by:/ {mntby=$0} /^source:/ {source=$0; if (source !~ /RPKI/) {print route; print origin; if (mntby != "") print mntby; print source} route=""; origin=""; mntby=""; source=""}'))
		
			if [ ${#PREFIXES[@]} -eq 0 ]; then
				if [ "$DEBUG" = "1" ]; then 
					printf_debug "DEBUG: No prefix origins found for aut-num: ["$MEMBER"] in ["$SOURCE"]"
				fi 
				if [ "$WARNING" = "1" ]; then
					printf_warn "WARNING: $current_as_set_chain member: $MEMBER enumerates no originated routes!"
				fi
				continue
			fi

            for PREFIX in "${PREFIXES[@]}"; do	# begin for PREFIX
                if [ -n "$current_as_set_chain" ] && [ -n "$MEMBER" ] && [ -n "$PREFIX" ]; then
					if [ -z "${VISITED_PFX["$PREFIX"]}" ]; then
						VISITED_PFX["$PREFIX"]=false
					fi
					if [ "$DEBUG" = "1" ]; then
						printf_debug "DEBUG: $PREFIX top of for PREFIX loop"
						printf_debug "DEBUG: for PREFIX loop PREFIX: $PREFIX"
						printf_debug "DEBUG: for PREFIX loop VISITED_PFX[PREFIX]: "${VISITED_PFX["$PREFIX"]}""
						printf_debug "DEBUG: determine the origin, mnt-by, and source for route: ["$PREFIX"]"
					fi
					# Collect origin, mnt-by, and source for the current prefix route: and store it
					IFS= ROUTE_IRR_OUT=($("$WHOIS" -h "$IRR" "\!g -x "$PREFIX"" | grep -e "^route:\|^origin:\|^mnt-by:\|^source:" | awk '/^route:/ {route=$0} /^origin:/ {origin=$0} /^mnt-by:/ {mntby=$0} /^source:/ {source=$0; if (source !~ /RPKI/) {print route; print origin; if (mntby != "") print mntby; print source} route=""; origin=""; mntby=""; source=""}'))
					if [ "$DEBUG" = "1" ]; then
						printf_debug "DEBUG: 702 ROUTE_IRR_OUT: ["$ROUTE_IRR_OUT"]"
					fi
					
					# set AUT_MNT
					AUT_MNT=$(echo "${AUT_MNT_ARRAY[0]}" | awk '{$1=$1};1')
					
					# Count the number of route: objects found in IRR
					IFS=' ' read -r -a ROUTE_QTY <<< $(echo -e "$ROUTE_IRR_OUT" | grep -e "^route:\|^source:" | awk '/^route:/ {route=$0} /^source:/ {source=$0; if (source !~ /RPKI/) {print route} route=""; source=""}' | awk '{print $1}' | tr '\n' ' ')

					# Parse origins from ROUTE_IRR_OUT
					IFS=' '  read -r -a ROUTE_ORIGIN <<< $(echo -e "$ROUTE_IRR_OUT" | awk 'BEGIN {IGNORECASE=1} /^origin:/ {print $2}' | tr '\n' ' ') 
					
					# Parse maintainers from ROUTE_IRR_OUT
					IFS=' ' read -r -a ROUTE_MNT <<< $(echo -e "$ROUTE_IRR_OUT" | awk 'BEGIN {IGNORECASE=1} /^mnt-by:/ {print $2}' | tr '\n' ' ')
					# Parse sources from ROUTE_IRR_OUT
					IFS=' ' read -r -a ROUTE_SRC <<< $(echo -e "$ROUTE_IRR_OUT" | awk 'BEGIN {IGNORECASE=1} /^source:/ {print $2}' | tr '\n' ' ')
					
					if [ "$DEBUG" = "1" ]; then
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_ORIGIN[i]: [${ROUTE_ORIGIN["$i"]}]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT count ROUTE_ORIGIN[@]: ["${#ROUTE_ORIGIN[@]}"]"
						printf_debug "DEBUG: All ROUTE_ORIGIN values: [${ROUTE_ORIGIN[@]}]"
						for i in "${!ROUTE_ORIGIN[@]}"; do
  							printf_debug "DEBUG: ROUTE_ORIGIN[%d]: [%s]" "$i" "${ROUTE_ORIGIN[i]}"
						done
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_MNT[@]: ["${ROUTE_MNT[@]}"]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_MNT[i]: ["${ROUTE_MNT["$i"]}"]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_SRC[@]: [${ROUTE_SRC[@]}]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_SRC[i]: [${ROUTE_SRC["$i"]}]"
						printf_debug "DEBUG: parse ROUTE_IRR_OUT ROUTE_SRC: [$ROUTE_SRC]"
					fi
					# Check if ROUTE_SRC has already been processed
					for i in "${!ROUTE_SRC[@]}"; do		# begin for i 
						KVP="${PREFIX} ${ROUTE_SRC["$i"]} ${ROUTE_MNT["$i"]}"
						if [ -z "${VISITED_PFX_SRC[$KVP]}" ]; then	# set to integer 0 if length0/not exist
							if [ "$DEBUG" = "1" ]; then
								printf_debug "DEBUG: for i in ROUTE_SRC - VISITED_PFX_SRC[KVP] matches if -z ; setting to integer 0"
							fi
							VISITED_PFX_SRC[$KVP]=0
						fi

					if [ "$DEBUG" = "1" ]; then
						printf_debug "DEBUG: begin for i loop"
						printf_debug "DEBUG: in for i loop PREFIX: ["$PREFIX"]" 
						printf_debug "DEBUG: in for i loop {VISITED_PFX_SRC[@]}: ["${VISITED_PFX_SRC[@]}"]"
						printf_debug "DEBUG: in for i loop i: ["$i"]"
						printf_debug "DEBUG: in for i loop {VISITED_PFX_SRC[i]}: ["${VISITED_PFX_SRC["$i"]}"]"
						printf_debug "DEBUG: in for i loop ROUTE_SRC: ["$ROUTE_SRC"]"
						printf_debug "DEBUG: in for i loop KVP: ["$KVP"]"
						printf_debug "DEBUG: in for i loop VISITED_PFX_SRC[KVP]: "${VISITED_PFX_SRC[$KVP]}"" 
						printf_debug "DEBUG: in for i loop count ROUTE_ORIGIN@*]: ["${#ROUTE_ORIGIN[@]}"]"
						printf_debug "DEBUG: in for i loop ROUTE_ORIGIN[i]: [${ROUTE_ORIGIN["$i"]}]"
					fi

					if [ "${VISITED_PFX_SRC[$KVP]}" = "0" ]; then
						# Check for multiple origins of this route
						for o in "${!ROUTE_ORIGIN[@]}"; do	# begin for o
							KVP="${PREFIX} ${ROUTE_SRC[$o]} ${ROUTE_MNT[$o]}"
							if [ "$DEBUG" = "1" ]; then
								printf_debug "DEBUG: for o loop iteration start"
								printf_debug "DEBUG: in for o loop - Parsing route object KVP: ["$KVP"]"
								printf_debug "DEBUG: in for o loop - VISITED_PFX[PREFIX]: ${VISITED_PFX["$PREFIX"]}"
								printf_debug "DEBUG: in for o loop - ROUTE_ORIGIN[o]: [${ROUTE_ORIGIN[$o]}]"
								printf_debug "DEBUG: in for o loop - ROUTE_MNT[o]: [${ROUTE_MNT[$o]}]"
								printf_debug "DEBUG: in for o loop - ROUTE_SRC[o]: [${ROUTE_SRC[$o]}]"
								printf_debug "DEBUG: in for o loop - AUT_MNT_ARRAY[@]: ["${AUT_MNT_ARRAY[@]}"]"
								printf_debug "DBEUG: in for o loop - MEMBER: [$MEMBER]"
								printf_debug "DEBUG: in for o loop - AUT_MNT: ["$AUT_MNT"]"
							fi
							if [ "${VISITED_PFX_SRC[$KVP]}" = "1" ]; then
								if [ "$DEBUG" = "1" ]; then
									printf_debug "DEBUG: VISITED_PFX_SRC[KVP]=1 ; continue and bail out of (continue) for o - KVP: ["$KVP"]"
								fi
								continue
                        	fi

							# OUTPUT
							if [ "${VISITED_PFX["$PREFIX"]}" = "true" ]; then	
								continue
							elif [ "${VISITED_PFX["$PREFIX"]}" = "false" ]; then 
								CIDRMASK="${PREFIX##*/}"
								do_output

								# Now determine which scenario matches the data parsed
								# Not sure this is needed any longer...

								if [ "$RIR_ORIGIN" != "$ROUTE_ORIGIN" ]; then	# Found RIR origin but mismatch with route origin - case 4
									PFX_MATCH="c4"
								elif [ "${ROUTE_ORIGIN[$o]}" == "$MEMBER" ] &&  [ "${ROUTE_MNT[$o]}" == "$AUT_MNT" ]; then	# valid data match - case 0
									PFX_MATCH="c0"
								elif [ "${ROUTE_ORIGIN[$o]}" == "$MEMBER" ] && [ "${ROUTE_MNT[$o]}" != "$AUT_MNT" ]; then	# mnt mismatch but will work - case 1
									PFX_MATCH="c1"
                        		elif [ "${ROUTE_ORIGIN[$o]}" != "$MEMBER" ]; then    # origin/member mismatch - bogus IRR objects - case 2
									PFX_MATCH="c2"
								elif [ "${#ROUTE_SRC[@]}" -gt 1 ]; then		# identical route and attributes in multiple registries - case 3
									PFX_MATCH="c3"
								else
									PFX_MATCH="nomatch"
									# CHANGE TO DEBUG
									printf_debug "no case matched for prefix $PREFIX"
								fi

								if [ "$DEBUG" = "1" ]; then
									printf_debug "DEBUG: end of for o iteration"
								fi
							fi
						done	# end for o
						if [ "$DEBUG" = "1" ]; then
                            printf_debug "DEBUG: end of in for i loop for "[$PREFIX]" + ["$ROUTE_SRC"]"
							printf_debug "DEBUG: VISITED_PFX_SRC[KVP]: ["$VISITED_PFX_SRC[$KVP]"]"
						fi
				fi
		 	done	# end for i
			if [ "$DEBUG" = "1" ]; then
				printf_debug "DEBUG: for i in ROUTE_SRC loop ended"
			fi
		    fi
			unset RIR_ORIGIN
		    if [ "$DEBUG" = "1" ]; then
			    printf_debug "DEBUG: unset RIR_ORIGIN"
			    printf_debug "DEBUG: $PREFIX end of for PREFIX loop"
		    fi
	    done	# end for PREFIX
            fi
        fi
    done <<< "$MEMBERS"

    # Process AS-SET members (AS-SET objects)
    while IFS= read -r MEMBER_ASS; do
        MEMBER_ASS=$(echo "$MEMBER_ASS" | tr -d '[:space:][:cntrl:]')

	# "don't want none unless you got buns, hun!" - Dan
        if [[ -z "$MEMBER_ASS" ]]; then
            continue
        fi

        if [ -n "${VISITED_AS_SETS[$MEMBER_ASS]}" ]; then
		printf "\033[37m\033[44m%-18s %-70s %-10s %-12s \033[1;37m%sWARNING: AS-SET recursion loop!\033[0m\n" \
			"" "$current_as_set_chain" "$MEMBER" "$ROUTE_SRC" ""
		#continue
		return
	fi
        #    echo "ERROR: Circular reference detected for AS-SET: "$MEMBER_ASS""
        #    continue
        #fi

        VISITED_AS_SETS["$MEMBER_ASS"]=1

        # Recursively process nested AS-SETs
        current_as_set_chain=$(modify_as_chain "$current_as_set_chain" "$MEMBER_ASS")
        process_as_sets "$MEMBER_ASS"
    done <<< "$MEMBERS_ASS"

    # Pop the current AS-SET after processing
    if [ "${#AS_SET_STACK[@]}" -gt 0 ]; then
		if [ "$DEBUG" = "1" ]; then
			printf_debug "DEBUG: unset AS_SET_STACK"
		fi
        unset 'AS_SET_STACK[${#AS_SET_STACK[@]}-1]'
		else
			if [ "$DEBUG" = "1" ]; then
				printf_debug "DEBUG: if AS_SET_STACK eval fell through to else"
			fi
    fi
}

# Start processing from the initial AS-SET
if [ "$DEBUG" = "1" ]; then
    printf_debug "DEBUG: Starting with AS-SET: [$AS_SET]"
fi

# Process initial AS-SET and its aut-nums
irr_prefix_count=0
process_as_sets "$AS_SET"
if [ "$DEBUG" = "1" ]; then
	printf_debug "DEBUG: end of iteration for processing initial as-set and aut-nums from AS_SET"
fi
if [ "$QUIET" = "0" ]; then
	echo "----"
	echo "Total prefix count (IRR): $irr_prefix_count"
	END_TIME=$(date +%s.%N)
	EXEC_TIME=$(echo "$END_TIME - $START_TIME" | bc)
	printf "Script execution time: [%.2f secs]\n" "$EXEC_TIME"
fi
